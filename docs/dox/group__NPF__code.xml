<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<section xmlns="http://docbook.org/ns/docbook" version="5.0" xmlns:xlink="http://www.w3.org/1999/xlink" xml:id="group__NPF__code">
    <title>NPF functions</title>
        <section>
            <title>Detailed Description</title>
        </section>
        <section>
            <title>Variables</title>
            <para>
                <itemizedlist>
                    <listitem>
                        <para>FILTER_SET_OPTIONS <link linkend="group__NPF__code_1ga5115bd8dde51e2781e7b4e0399aec26f">NPF_RegisterOptions</link></para>
                    </listitem>
                </itemizedlist>
            </para>
            <para>
                <itemizedlist>
                    <listitem>
                        <para>FILTER_ATTACH <link linkend="group__NPF__code_1gaff02b0a70a0aa85620445b9c197dc5de">NPF_AttachAdapter</link><para><emphasis>Callback for NDIS AttachHandler. Not used by NPF.</emphasis></para>
</para>
                    </listitem>
                </itemizedlist>
            </para>
            <para>
                <itemizedlist>
                    <listitem>
                        <para>FILTER_DETACH <link linkend="group__NPF__code_1ga6b9046210a2eb5b094f17e0f456ec893">NPF_DetachAdapter</link><para><emphasis>Callback for NDIS DetachHandler.</emphasis></para>
</para>
                    </listitem>
                </itemizedlist>
            </para>
            <para>
                <itemizedlist>
                    <listitem>
                        <para>DRIVER_UNLOAD <link linkend="group__NPF__code_1ga764f5c22ede74a9311342cd19421f545">NPF_Unload</link><para><emphasis>Function called by the OS when NPF is unloaded.</emphasis></para>
</para>
                    </listitem>
                </itemizedlist>
            </para>
            <para>
                <itemizedlist>
                    <listitem>
                        <para>FILTER_RESTART <link linkend="group__NPF__code_1ga23d3565bbfb71db9fcdb83bfae29492c">NPF_Restart</link><para><emphasis>Filter restart routine, callback for NDIS RestartHandler.</emphasis></para>
</para>
                    </listitem>
                </itemizedlist>
            </para>
            <para>
                <itemizedlist>
                    <listitem>
                        <para>FILTER_PAUSE <link linkend="group__NPF__code_1ga95739fd0dc3f0706723f6fa4528972b1">NPF_Pause</link><para><emphasis>Filter pause routine, Callback for NDIS PauseHandler.</emphasis></para>
</para>
                    </listitem>
                </itemizedlist>
            </para>
            <para>
                <itemizedlist>
                    <listitem>
                        <para>FILTER_OID_REQUEST <link linkend="group__NPF__code_1ga10ee17ea67d95bb3181d15504766af8b">NPF_OidRequest</link></para>
                    </listitem>
                </itemizedlist>
            </para>
            <para>
                <itemizedlist>
                    <listitem>
                        <para>FILTER_CANCEL_OID_REQUEST <link linkend="group__NPF__code_1gacb9e2c3fa9a52b1100a33fa71ee2f375">NPF_CancelOidRequest</link></para>
                    </listitem>
                </itemizedlist>
            </para>
            <para>
                <itemizedlist>
                    <listitem>
                        <para>FILTER_OID_REQUEST_COMPLETE <link linkend="group__NPF__code_1ga19e4d4a1b5137ac74dad1fbd8c1ea43d">NPF_OidRequestComplete</link></para>
                    </listitem>
                </itemizedlist>
            </para>
            <para>
                <itemizedlist>
                    <listitem>
                        <para>FILTER_STATUS <link linkend="group__NPF__code_1gadfce5805f2e2026d08c275bd495cc87a">NPF_Status</link><para><emphasis>Callback for NDIS StatusHandler. Not used by NPF.</emphasis></para>
</para>
                    </listitem>
                </itemizedlist>
            </para>
            <para>
                <itemizedlist>
                    <listitem>
                        <para>FILTER_DEVICE_PNP_EVENT_NOTIFY <link linkend="group__NPF__code_1gaeae1fa7b69f4374d66377f02aebb7c30">NPF_DevicePnPEventNotify</link><para><emphasis>Device PNP event handler.</emphasis></para>
</para>
                    </listitem>
                </itemizedlist>
            </para>
            <para>
                <itemizedlist>
                    <listitem>
                        <para>FILTER_NET_PNP_EVENT <link linkend="group__NPF__code_1ga81b05ccf273c2f945fb3f21da2788649">NPF_NetPnPEvent</link><para><emphasis>Net PNP event handler.</emphasis></para>
</para>
                    </listitem>
                </itemizedlist>
            </para>
            <para>
                <itemizedlist>
                    <listitem>
                        <para>FILTER_SEND_NET_BUFFER_LISTS <link linkend="group__NPF__code_1ga8a224321a819c50b39c65deb6feb2990">NPF_SendEx</link><para><emphasis>Callback for NDIS SendNetBufferListsHandler.</emphasis></para>
</para>
                    </listitem>
                </itemizedlist>
            </para>
            <para>
                <itemizedlist>
                    <listitem>
                        <para>FILTER_RETURN_NET_BUFFER_LISTS <link linkend="group__NPF__code_1ga7bf507f2ea2c1a99e425d983f522718e">NPF_ReturnEx</link><para><emphasis>Callback for NDIS ReturnNetBufferListsHandler.</emphasis></para>
</para>
                    </listitem>
                </itemizedlist>
            </para>
            <para>
                <itemizedlist>
                    <listitem>
                        <para>FILTER_SEND_NET_BUFFER_LISTS_COMPLETE <link linkend="group__NPF__code_1gaf574b5a81173554f2c44f197d633c882">NPF_SendCompleteEx</link><para><emphasis>Callback for NDIS SendNetBufferListsCompleteHandler.</emphasis></para>
</para>
                    </listitem>
                </itemizedlist>
            </para>
            <para>
                <itemizedlist>
                    <listitem>
                        <para>FILTER_RECEIVE_NET_BUFFER_LISTS <link linkend="group__NPF__code_1ga97357217815d777965c6114fde014b4c">NPF_TapEx</link><para><emphasis>Callback for NDIS ReceiveNetBufferListsHandler.</emphasis></para>
</para>
                    </listitem>
                </itemizedlist>
            </para>
            <para>
                <itemizedlist>
                    <listitem>
                        <para>FILTER_CANCEL_SEND_NET_BUFFER_LISTS <link linkend="group__NPF__code_1ga68e4564ae596b0fb6b947a9485cc4102">NPF_CancelSendNetBufferLists</link><para><emphasis>Callback for NDIS CancelSendNetBufferListsHandler.</emphasis></para>
</para>
                    </listitem>
                </itemizedlist>
            </para>
            <para>
                <itemizedlist>
                    <listitem>
                        <para>FILTER_SET_MODULE_OPTIONS <link linkend="group__NPF__code_1gaf92ab7626caa4a270cfad07ad97da927">NPF_SetModuleOptions</link><para><emphasis>Callback for NDIS SetFilterModuleOptionsHandler.</emphasis></para>
</para>
                    </listitem>
                </itemizedlist>
            </para>
            <para>
                <itemizedlist>
                    <listitem>
                        <para>DRIVER_INITIALIZE <link linkend="group__NPF__code_1ga4fdcbea54bcb9f97ab54ae0f41650622">DriverEntry</link><para><emphasis>The initialization routine of the driver.</emphasis></para>
</para>
                    </listitem>
                </itemizedlist>
            </para>
        </section>
        <section>
            <title>Functions</title>
            <para>
                <itemizedlist>
                    <listitem>
                        <para>VOID <link linkend="group__NPF__code_1ga8fcbaebfdbada64f9762e31fa96e9d6a">NPF_FreePackets</link> (
PNET_BUFFER_LIST NetBufferLists)<para><emphasis>Function to free the Net Buffer Lists initiated by ourself.</emphasis></para>
</para>
                    </listitem>
                </itemizedlist>
            </para>
            <para>
                <itemizedlist>
                    <listitem>
                        <para>ULONG <link linkend="group__NPF__code_1ga4038247452c950134c0cb87609348469">NPF_GetPhysicalMedium</link> (
NDIS_HANDLE FilterModuleContext)<para><emphasis>Get the physical medium of the adapter.</emphasis></para>
</para>
                    </listitem>
                </itemizedlist>
            </para>
            <para>
                <itemizedlist>
                    <listitem>
                        <para>ULONG <link linkend="group__NPF__code_1ga16173e745bd6a3d0ead21256de38520e">NPF_GetPacketFilter</link> (
NDIS_HANDLE FilterModuleContext)<para><emphasis>Get the packet filter of the adapter.</emphasis></para>
</para>
                    </listitem>
                </itemizedlist>
            </para>
            <para>
                <itemizedlist>
                    <listitem>
                        <para>NDIS_STATUS <link linkend="group__NPF__code_1ga40afb45f4ad8ac44da6d0b4b80c09568">NPF_SetPacketFilter</link> (
NDIS_HANDLE FilterModuleContext, ULONG PacketFilter)<para><emphasis>Set the packet filter of the adapter.</emphasis></para>
</para>
                    </listitem>
                </itemizedlist>
            </para>
            <para>
                <itemizedlist>
                    <listitem>
                        <para>NDIS_STATUS <link linkend="group__NPF__code_1gacaf4bc2ac781a1f215a92c930afc3ba6">NPF_DoInternalRequest</link> (
_In_ NDIS_HANDLE FilterModuleContext, _In_ NDIS_REQUEST_TYPE RequestType, _In_ NDIS_OID Oid, _Inout_updates_bytes_to_(InformationBufferLength, *pBytesProcessed) PVOID InformationBuffer, _In_ ULONG InformationBufferLength, _In_opt_ ULONG OutputBufferLength, _In_ ULONG MethodId, _Out_ PULONG pBytesProcessed)<para><emphasis>Utility routine that forms and sends an NDIS_OID_REQUEST to the miniport adapter.</emphasis></para>
</para>
                    </listitem>
                </itemizedlist>
            </para>
            <para>
                <itemizedlist>
                    <listitem>
                        <para>VOID <link linkend="group__NPF__code_1ga0f4ceafd1a03ffa4999224d381f05069">NPF_InternalRequestComplete</link> (
_In_ NDIS_HANDLE FilterModuleContext, _In_ PNDIS_OID_REQUEST NdisRequest, _In_ NDIS_STATUS Status)<para><emphasis>Self-sent request handler.</emphasis></para>
</para>
                    </listitem>
                </itemizedlist>
            </para>
            <para>
                <itemizedlist>
                    <listitem>
                        <para>ULONG <link linkend="group__NPF__code_1ga03c8b625d6dbd8c32aa052e75d91faf0">My_NdisGroupMaxProcessorCount</link> (
)<para><emphasis>Returns the maximum number of processors in the machine.</emphasis></para>
</para>
                    </listitem>
                </itemizedlist>
            </para>
            <para>
                <itemizedlist>
                    <listitem>
                        <para>ULONG <link linkend="group__NPF__code_1gac13d66181916327d6ec6ea241aa92d31">My_KeGetCurrentProcessorNumber</link> (
)<para><emphasis>Returns the processor number of the logical processor that the caller is running on.</emphasis></para>
</para>
                    </listitem>
                </itemizedlist>
            </para>
            <para>
                <itemizedlist>
                    <listitem>
                        <para>VOID <link linkend="group__NPF__code_1ga583e25304494a20cc26b314f35b4c4a7">NPF_registerLWF</link> (
PNDIS_FILTER_DRIVER_CHARACTERISTICS pFChars, BOOLEAN bWiFiOrNot)<para><emphasis>The initialization routine of the LWF data structure.</emphasis></para>
</para>
                    </listitem>
                </itemizedlist>
            </para>
            <para>
                <itemizedlist>
                    <listitem>
                        <para>PWCHAR <link linkend="group__NPF__code_1ga4d4285c1178ae2e7aa2ee2e7cbb962fa">getAdaptersList</link> (
)<para><emphasis>Returns the list of the MACs available on the system.</emphasis></para>
</para>
                    </listitem>
                </itemizedlist>
            </para>
            <para>
                <itemizedlist>
                    <listitem>
                        <para>PKEY_VALUE_PARTIAL_INFORMATION <link linkend="group__NPF__code_1gac9fd20e0896f418bcbe8891cac9264a6">getTcpBindings</link> (
)<para><emphasis>Returns the MACs that bind to TCP/IP.</emphasis></para>
</para>
                    </listitem>
                </itemizedlist>
            </para>
            <para>
                <itemizedlist>
                    <listitem>
                        <para>ULONG <link linkend="group__NPF__code_1gaea8c5091e715c9fe3861b85eb9df3fa9">NPF_GetRegistryOption_Integer</link> (
PUNICODE_STRING RegistryPath, PUNICODE_STRING RegValueName)<para><emphasis>read Npcap software&apos;s registry, get the option.</emphasis></para>
</para>
                    </listitem>
                </itemizedlist>
            </para>
            <para>
                <itemizedlist>
                    <listitem>
                        <para>VOID <link linkend="group__NPF__code_1ga3d90362bd8afff10c568dacf8da63497">NPF_GetRegistryOption_String</link> (
)<para><emphasis>read Npcap software&apos;s registry, get the loopback adapter&apos;s device name and then put the name into global variable: g_LoopbackAdapterName. This name will be check in NPF_CreateDevice() function.</emphasis></para>
</para>
                    </listitem>
                </itemizedlist>
            </para>
            <para>
                <itemizedlist>
                    <listitem>
                        <para>BOOLEAN <link linkend="group__NPF__code_1ga9a0324855f0f3c78f5849141b2b762c1">NPF_CreateDevice</link> (
IN OUT PDRIVER_OBJECT DriverObject, IN PUNICODE_STRING AdapterName, IN PUNICODE_STRING NPF_Prefix, IN BOOLEAN Dot11)<para><emphasis>Creates a device for a given MAC.</emphasis></para>
</para>
                    </listitem>
                </itemizedlist>
            </para>
            <para>
                <itemizedlist>
                    <listitem>
                        <para> <link linkend="group__NPF__code_1ga27adfea80e4f27216ea3e26ea4824abc">_Dispatch_type_</link> (
IRP_MJ_CREATE )<para><emphasis>Opens a new instance of the driver.</emphasis></para>
</para>
                    </listitem>
                </itemizedlist>
            </para>
            <para>
                <itemizedlist>
                    <listitem>
                        <para> <link linkend="group__NPF__code_1ga8eb569f58457bc951486e6d07dee9d67">_Dispatch_type_</link> (
IRP_MJ_CLEANUP )<para><emphasis>Closes an instance of the driver.</emphasis></para>
</para>
                    </listitem>
                </itemizedlist>
            </para>
            <para>
                <itemizedlist>
                    <listitem>
                        <para> <link linkend="group__NPF__code_1ga2db095d0ced7dc5f32deba345ee42456">_Dispatch_type_</link> (
IRP_MJ_CLOSE )<para><emphasis>Closes an instance of the driver.</emphasis></para>
</para>
                    </listitem>
                </itemizedlist>
            </para>
            <para>
                <itemizedlist>
                    <listitem>
                        <para>VOID <link linkend="group__NPF__code_1gae4ee83bd493a7fd3d57a43ace557f5ca">NPF_TapExForEachOpen</link> (
IN <link linkend="group__NPF__include_1gad3b7ff25cfe0e8fd50666782f85e76cb">POPEN_INSTANCE</link> Open, IN PNET_BUFFER_LIST pNetBufferLists)<para><emphasis>Callback invoked by NPF_TapEx() when a packet arrives from the network.</emphasis></para>
</para>
                    </listitem>
                </itemizedlist>
            </para>
            <para>
                <itemizedlist>
                    <listitem>
                        <para> <link linkend="group__NPF__code_1ga574f32dfea14937d984bfe6cea990661">_Dispatch_type_</link> (
IRP_MJ_DEVICE_CONTROL )<para><emphasis>Handles the IOCTL calls.</emphasis></para>
</para>
                    </listitem>
                </itemizedlist>
            </para>
            <para>
                <itemizedlist>
                    <listitem>
                        <para> <link linkend="group__NPF__code_1ga6ce38ed96776a52a17ab033de5b6d0df">_Dispatch_type_</link> (
IRP_MJ_WRITE )<para><emphasis>Writes a raw packet to the network.</emphasis></para>
</para>
                    </listitem>
                </itemizedlist>
            </para>
            <para>
                <itemizedlist>
                    <listitem>
                        <para>INT <link linkend="group__NPF__code_1ga9a97dd25ae757da4bfed3723a4eb4bce">NPF_BufferedWrite</link> (
IN PIRP Irp, IN PCHAR UserBuff, IN ULONG UserBuffSize, BOOLEAN sync)<para><emphasis>Writes a buffer of raw packets to the network.</emphasis></para>
</para>
                    </listitem>
                </itemizedlist>
            </para>
            <para>
                <itemizedlist>
                    <listitem>
                        <para>VOID <link linkend="group__NPF__code_1ga8861b474efcb6578c9fe2075ff3e6aef">NPF_WaitEndOfBufferedWrite</link> (
<link linkend="group__NPF__include_1gad3b7ff25cfe0e8fd50666782f85e76cb">POPEN_INSTANCE</link> Open)<para><emphasis>Waits the completion of all the sends performed by NPF_BufferedWrite.</emphasis></para>
</para>
                    </listitem>
                </itemizedlist>
            </para>
            <para>
                <itemizedlist>
                    <listitem>
                        <para>VOID <link linkend="group__NPF__code_1ga4290c442943ae36cf616862137ca0a87">NPF_SendCompleteExForEachOpen</link> (
IN <link linkend="group__NPF__include_1gad3b7ff25cfe0e8fd50666782f85e76cb">POPEN_INSTANCE</link> Open, BOOLEAN FreeBufAfterWrite)<para><emphasis>Ends a send operation.</emphasis></para>
</para>
                    </listitem>
                </itemizedlist>
            </para>
            <para>
                <itemizedlist>
                    <listitem>
                        <para>VOID <link linkend="group__NPF__code_1gae116b69870512a8b9f12c2e246d043e5">NPF_StatusEx</link> (
IN NDIS_HANDLE ProtocolBindingContext, IN PNDIS_STATUS_INDICATION StatusIndication)<para><emphasis>Callback for NDIS StatusHandler. Not used by NPF.</emphasis></para>
</para>
                    </listitem>
                </itemizedlist>
            </para>
            <para>
                <itemizedlist>
                    <listitem>
                        <para>VOID <link linkend="group__NPF__code_1ga70f97109adcd6de8b157534e5ecf2e56">NPF_StatusComplete</link> (
IN NDIS_HANDLE ProtocolBindingContext)<para><emphasis>Callback for NDIS StatusCompleteHandler. Not used by NPF.</emphasis></para>
</para>
                    </listitem>
                </itemizedlist>
            </para>
            <para>
                <itemizedlist>
                    <listitem>
                        <para> <link linkend="group__NPF__code_1ga6330e925342da5060d8968dbbecfabdc">_Dispatch_type_</link> (
IRP_MJ_READ )<para><emphasis>Function that serves the user&apos;s reads.</emphasis></para>
</para>
                    </listitem>
                </itemizedlist>
            </para>
            <para>
                <itemizedlist>
                    <listitem>
                        <para>void <link linkend="group__NPF__code_1gad04266456ecaa437122eee8dd3eddeca">NPF_AddToOpenArray</link> (
<link linkend="group__NPF__include_1gad3b7ff25cfe0e8fd50666782f85e76cb">POPEN_INSTANCE</link> Open)<para><emphasis>Add the open context to the global open array.</emphasis></para>
</para>
                    </listitem>
                </itemizedlist>
            </para>
            <para>
                <itemizedlist>
                    <listitem>
                        <para>void <link linkend="group__NPF__code_1ga200a4e395f43a9b0a6769986dd0d9563">NPF_AddToGroupOpenArray</link> (
<link linkend="group__NPF__include_1gad3b7ff25cfe0e8fd50666782f85e76cb">POPEN_INSTANCE</link> Open, <link linkend="group__NPF__include_1gad3b7ff25cfe0e8fd50666782f85e76cb">POPEN_INSTANCE</link> GroupHead)<para><emphasis>Add the open context to the group open array of a head adapter.</emphasis></para>
</para>
                    </listitem>
                </itemizedlist>
            </para>
            <para>
                <itemizedlist>
                    <listitem>
                        <para>void <link linkend="group__NPF__code_1gabbdcba53431b4b034a2865a357fe7139">NPF_RemoveFromOpenArray</link> (
<link linkend="group__NPF__include_1gad3b7ff25cfe0e8fd50666782f85e76cb">POPEN_INSTANCE</link> Open)<para><emphasis>Remove the open context from the global open array.</emphasis></para>
</para>
                    </listitem>
                </itemizedlist>
            </para>
            <para>
                <itemizedlist>
                    <listitem>
                        <para>void <link linkend="group__NPF__code_1gacd6b083f1069a6ace93f867e063547d7">NPF_RemoveFromGroupOpenArray</link> (
<link linkend="group__NPF__include_1gad3b7ff25cfe0e8fd50666782f85e76cb">POPEN_INSTANCE</link> Open)<para><emphasis>Remove the open context from the group open array of a head adapter.</emphasis></para>
</para>
                    </listitem>
                </itemizedlist>
            </para>
            <para>
                <itemizedlist>
                    <listitem>
                        <para>BOOLEAN <link linkend="group__NPF__code_1ga9239d79ad62d1d56393963d076b42949">NPF_EqualAdapterName</link> (
PNDIS_STRING s1, PNDIS_STRING s2)<para><emphasis>Compare two NDIS strings.</emphasis></para>
</para>
                    </listitem>
                </itemizedlist>
            </para>
            <para>
                <itemizedlist>
                    <listitem>
                        <para><link linkend="group__NPF__include_1gad3b7ff25cfe0e8fd50666782f85e76cb">POPEN_INSTANCE</link> <link linkend="group__NPF__code_1ga2c7bf9f627c395096f806bad0ebd41cf">NPF_GetOpenByAdapterName</link> (
PNDIS_STRING pAdapterName, BOOLEAN Dot11)<para><emphasis>Get a copy of open instance from the global array.</emphasis></para>
</para>
                    </listitem>
                </itemizedlist>
            </para>
            <para>
                <itemizedlist>
                    <listitem>
                        <para><link linkend="group__NPF__include_1gad3b7ff25cfe0e8fd50666782f85e76cb">POPEN_INSTANCE</link> <link linkend="group__NPF__code_1ga759d14a6f8a32feaf146505024f77cfa">NPF_DuplicateOpenObject</link> (
<link linkend="group__NPF__include_1gad3b7ff25cfe0e8fd50666782f85e76cb">POPEN_INSTANCE</link> OriginalOpen, <link linkend="group__NPF__include_1gac8ad25578be589c8352fc4e1a8a99be3">PDEVICE_EXTENSION</link> DeviceExtension)<para><emphasis>Get a copy of open instance from the global array.</emphasis></para>
</para>
                    </listitem>
                </itemizedlist>
            </para>
            <para>
                <itemizedlist>
                    <listitem>
                        <para><link linkend="group__NPF__include_1gad3b7ff25cfe0e8fd50666782f85e76cb">POPEN_INSTANCE</link> <link linkend="group__NPF__code_1ga9b229409688200ac6e9b1ef66e32a3ed">NPF_CreateOpenObject</link> (
PNDIS_STRING AdapterName, UINT SelectedIndex, <link linkend="group__NPF__include_1gac8ad25578be589c8352fc4e1a8a99be3">PDEVICE_EXTENSION</link> DeviceExtension)<para><emphasis>Create a open instance.</emphasis></para>
</para>
                    </listitem>
                </itemizedlist>
            </para>
            <para>
                <itemizedlist>
                    <listitem>
                        <para>NTSTATUS <link linkend="group__NPF__code_1gae3d1118c72b474fe214517a65afdfe09">NPF_OpenDumpFile</link> (
<link linkend="group__NPF__include_1gad3b7ff25cfe0e8fd50666782f85e76cb">POPEN_INSTANCE</link> Open, PUNICODE_STRING fileName, BOOLEAN append)<para><emphasis>Creates the file that will receive the packets when the driver is in dump mode.</emphasis></para>
</para>
                    </listitem>
                </itemizedlist>
            </para>
            <para>
                <itemizedlist>
                    <listitem>
                        <para>NTSTATUS <link linkend="group__NPF__code_1gaeffce124cbc3e3ae09bd7a6d10367cbb">NPF_StartDump</link> (
<link linkend="group__NPF__include_1gad3b7ff25cfe0e8fd50666782f85e76cb">POPEN_INSTANCE</link> Open)<para><emphasis>Starts dump to file.</emphasis></para>
</para>
                    </listitem>
                </itemizedlist>
            </para>
            <para>
                <itemizedlist>
                    <listitem>
                        <para>VOID <link linkend="group__NPF__code_1ga1566082cef91cf79ba4a855e3f44ede9">NPF_DumpThread</link> (
PVOID Open)<para><emphasis>The dump thread.</emphasis></para>
</para>
                    </listitem>
                </itemizedlist>
            </para>
            <para>
                <itemizedlist>
                    <listitem>
                        <para>NTSTATUS <link linkend="group__NPF__code_1gafcdcf5a4d9bfb8fbdb179963d4c789bd">NPF_SaveCurrentBuffer</link> (
<link linkend="group__NPF__include_1gad3b7ff25cfe0e8fd50666782f85e76cb">POPEN_INSTANCE</link> Open)<para><emphasis>Saves the content of the packet buffer to the file associated with current instance.</emphasis></para>
</para>
                    </listitem>
                </itemizedlist>
            </para>
            <para>
                <itemizedlist>
                    <listitem>
                        <para>VOID <link linkend="group__NPF__code_1ga57b9ee7752f00c8858bda8ca060a033b">NPF_WriteDumpFile</link> (
PFILE_OBJECT FileObject, PLARGE_INTEGER Offset, ULONG Length, PMDL Mdl, PIO_STATUS_BLOCK IoStatusBlock)<para><emphasis>Writes a block of packets on the dump file.</emphasis></para>
</para>
                    </listitem>
                </itemizedlist>
            </para>
            <para>
                <itemizedlist>
                    <listitem>
                        <para>NTSTATUS <link linkend="group__NPF__code_1gac911742b9f71c12c77452614db14c4a1">NPF_CloseDumpFile</link> (
<link linkend="group__NPF__include_1gad3b7ff25cfe0e8fd50666782f85e76cb">POPEN_INSTANCE</link> Open)<para><emphasis>Closes the dump file associated with an instance of the driver.</emphasis></para>
</para>
                    </listitem>
                </itemizedlist>
            </para>
            <para>
                <itemizedlist>
                    <listitem>
                        <para>BOOLEAN <link linkend="group__NPF__code_1ga64dab96bfced5d22cc55a42fc6339833">NPF_StartUsingBinding</link> (
IN <link linkend="group__NPF__include_1gad3b7ff25cfe0e8fd50666782f85e76cb">POPEN_INSTANCE</link> pOpen)</para>
                    </listitem>
                </itemizedlist>
            </para>
            <para>
                <itemizedlist>
                    <listitem>
                        <para>VOID <link linkend="group__NPF__code_1gacd54077d4c2d9186486d3504523ba4f0">NPF_StopUsingBinding</link> (
IN <link linkend="group__NPF__include_1gad3b7ff25cfe0e8fd50666782f85e76cb">POPEN_INSTANCE</link> pOpen)</para>
                    </listitem>
                </itemizedlist>
            </para>
            <para>
                <itemizedlist>
                    <listitem>
                        <para>VOID <link linkend="group__NPF__code_1ga76d4e48415cea8e0e65ba93d7355b89f">NPF_CloseBinding</link> (
IN <link linkend="group__NPF__include_1gad3b7ff25cfe0e8fd50666782f85e76cb">POPEN_INSTANCE</link> pOpen)</para>
                    </listitem>
                </itemizedlist>
            </para>
            <para>
                <itemizedlist>
                    <listitem>
                        <para>BOOLEAN <link linkend="group__NPF__code_1ga504e61b1229a9a604080fc8607b24084">NPF_StartUsingOpenInstance</link> (
IN <link linkend="group__NPF__include_1gad3b7ff25cfe0e8fd50666782f85e76cb">POPEN_INSTANCE</link> pOpen)</para>
                    </listitem>
                </itemizedlist>
            </para>
            <para>
                <itemizedlist>
                    <listitem>
                        <para>VOID <link linkend="group__NPF__code_1ga6ceb77291c077b05efd3b588a6a30867">NPF_StopUsingOpenInstance</link> (
IN <link linkend="group__NPF__include_1gad3b7ff25cfe0e8fd50666782f85e76cb">POPEN_INSTANCE</link> pOpen)</para>
                    </listitem>
                </itemizedlist>
            </para>
            <para>
                <itemizedlist>
                    <listitem>
                        <para>VOID <link linkend="group__NPF__code_1ga99878d91732973e7b4020d8e42b4cf32">NPF_CloseOpenInstance</link> (
IN <link linkend="group__NPF__include_1gad3b7ff25cfe0e8fd50666782f85e76cb">POPEN_INSTANCE</link> pOpen)</para>
                    </listitem>
                </itemizedlist>
            </para>
            <para>
                <itemizedlist>
                    <listitem>
                        <para>NTSTATUS <link linkend="group__NPF__code_1ga208c887c5d9e995e59a8f5a39ed191c7">NPF_GetDeviceMTU</link> (
IN <link linkend="group__NPF__include_1gad3b7ff25cfe0e8fd50666782f85e76cb">POPEN_INSTANCE</link> pOpen, OUT PUINT pMtu)</para>
                    </listitem>
                </itemizedlist>
            </para>
            <para>
                <itemizedlist>
                    <listitem>
                        <para>UINT <link linkend="group__NPF__code_1gadd6737f745e21b37b8613b489a96687d">GetBuffOccupation</link> (
<link linkend="group__NPF__include_1gad3b7ff25cfe0e8fd50666782f85e76cb">POPEN_INSTANCE</link> Open)<para><emphasis>Returns the amount of bytes present in the packet buffer.</emphasis></para>
</para>
                    </listitem>
                </itemizedlist>
            </para>
            <para>
                <itemizedlist>
                    <listitem>
                        <para>VOID <link linkend="group__NPF__code_1gae4089cbcd9d643328f7ac79200049e84">NPF_ResetBufferContents</link> (
<link linkend="group__NPF__include_1gad3b7ff25cfe0e8fd50666782f85e76cb">POPEN_INSTANCE</link> Open)</para>
                    </listitem>
                </itemizedlist>
            </para>
            <para>
                <itemizedlist>
                    <listitem>
                        <para><link linkend="structJIT__BPF__Filter">JIT_BPF_Filter</link> * <link linkend="group__NPF__code_1gab95019314e0cce415388272574f85ed7">BPF_jitter</link> (
struct bpf_insn * fp, INT nins)<para><emphasis>BPF jitter, builds an x86 function from a BPF program.</emphasis></para>
</para>
                    </listitem>
                </itemizedlist>
            </para>
            <para>
                <itemizedlist>
                    <listitem>
                        <para><link linkend="group__NPF__jitter_1ga17540919aa729f3e0b88ccb4d87d94d4">BPF_filter_function</link> <link linkend="group__NPF__code_1gaac4070271462268d182b0dbdbfcb1a88">BPFtoX86</link> (
struct bpf_insn * ins, UINT nins, INT * mem)<para><emphasis>Translates a set of BPF instructions in a set of x86 ones.</emphasis></para>
</para>
                    </listitem>
                </itemizedlist>
            </para>
            <para>
                <itemizedlist>
                    <listitem>
                        <para>void <link linkend="group__NPF__code_1ga8d441782c2295f2f71d32727dd3f28a0">BPF_Destroy_JIT_Filter</link> (
<link linkend="structJIT__BPF__Filter">JIT_BPF_Filter</link> * Filter)<para><emphasis>Deletes a filtering function that was previously created by BPF_jitter().</emphasis></para>
</para>
                    </listitem>
                </itemizedlist>
            </para>
        </section>
        <section>
            <title>Variable Documentation</title>
            <section xml:id="group__NPF__code_1ga5115bd8dde51e2781e7b4e0399aec26f">
                <title>FILTER_SET_OPTIONS NPF_RegisterOptions</title> <emphasis></emphasis>
                
            </section>
            <section xml:id="group__NPF__code_1gaff02b0a70a0aa85620445b9c197dc5de">
                <title>FILTER_ATTACH NPF_AttachAdapter</title> <emphasis>Callback for NDIS AttachHandler. Not used by NPF.</emphasis>
                
<para>
                <formalpara>
                    <title/>
                    <table frame="all">
                        <title>Parameters                        </title>
                        <tgroup cols="2" align="left" colsep="1" rowsep="1">
                        <colspec colwidth="1*"/>
                        <colspec colwidth="4*"/>
                        <tbody>
                            <row>
                                <entry>NdisFilterHandle</entry>
                                <entry>
<para>Specify a handle identifying this instance of the filter. FilterAttach should save this handle. It is a required parameter in subsequent calls to NdisFxxx functions. </para>
</entry>
                            </row>
                            <row>
                                <entry>FilterDriverContext</entry>
                                <entry>
<para>Filter driver context passed to NdisFRegisterFilterDriver. </para>
</entry>
                            </row>
                            <row>
                                <entry>AttachParameters</entry>
                                <entry>
<para>attach parameters. </para>
</entry>
                            </row>
                        </tbody>
                        </tgroup>
                    </table>
                </formalpara>
                <formalpara><title>Returns: </title>

<para>NDIS_STATUS_SUCCESS: FilterAttach successfully allocated and initialize data structures for this filter instance. NDIS_STATUS_RESOURCES: FilterAttach failed due to insufficient resources. NDIS_STATUS_FAILURE: FilterAttach could not set up this instance of this filter and it has called</para>
</formalpara>
Function called by NDIS when a new adapter is installed on the machine With Plug and Play. </para>

            </section>
            <section xml:id="group__NPF__code_1ga6b9046210a2eb5b094f17e0f456ec893">
                <title>FILTER_DETACH NPF_DetachAdapter</title> <emphasis>Callback for NDIS DetachHandler.</emphasis>
                
<para>
                <formalpara>
                    <title/>
                    <table frame="all">
                        <title>Parameters                        </title>
                        <tgroup cols="2" align="left" colsep="1" rowsep="1">
                        <colspec colwidth="1*"/>
                        <colspec colwidth="4*"/>
                        <tbody>
                            <row>
                                <entry>FilterModuleContext</entry>
                                <entry>
<para>Pointer to the filter context area.</para>
</entry>
                            </row>
                        </tbody>
                        </tgroup>
                    </table>
                </formalpara>
                Function called by NDIS when a new adapter is removed from the machine without shutting it down. NPF_DetachAdapter closes the adapter calling NdisCloseAdapter() and frees the memory and the structures associated with it. It also releases the waiting user-level app and closes the dump thread if the instance is in dump mode. </para>

            </section>
            <section xml:id="group__NPF__code_1ga764f5c22ede74a9311342cd19421f545">
                <title>DRIVER_UNLOAD NPF_Unload</title> <emphasis>Function called by the OS when NPF is unloaded.</emphasis>
                
<para>
                <formalpara>
                    <title/>
                    <table frame="all">
                        <title>Parameters                        </title>
                        <tgroup cols="2" align="left" colsep="1" rowsep="1">
                        <colspec colwidth="1*"/>
                        <colspec colwidth="4*"/>
                        <tbody>
                            <row>
                                <entry>DriverObject</entry>
                                <entry>
<para>The driver object of NPF created by the system.</para>
</entry>
                            </row>
                        </tbody>
                        </tgroup>
                    </table>
                </formalpara>
                This is the last function executed when the driver is unloaded from the system. It frees global resources, delete the devices and deregisters the filter. The driver can be unloaded by the user stopping the NPF service (from control panel or with a console &apos;net stop npf&apos;). </para>

            </section>
            <section xml:id="group__NPF__code_1ga23d3565bbfb71db9fcdb83bfae29492c">
                <title>FILTER_RESTART NPF_Restart</title> <emphasis>Filter restart routine, callback for NDIS RestartHandler.</emphasis>
                
<para>
                <formalpara>
                    <title/>
                    <table frame="all">
                        <title>Parameters                        </title>
                        <tgroup cols="2" align="left" colsep="1" rowsep="1">
                        <colspec colwidth="1*"/>
                        <colspec colwidth="4*"/>
                        <tbody>
                            <row>
                                <entry>FilterModuleContext</entry>
                                <entry>
<para>Pointer to the filter context structure. </para>
</entry>
                            </row>
                            <row>
                                <entry>RestartParameters</entry>
                                <entry>
<para>Additional information about the restart operation. </para>
</entry>
                            </row>
                        </tbody>
                        </tgroup>
                    </table>
                </formalpara>
                <formalpara><title>Returns: </title>

<para>NDIS_STATUS_SUCCESS: if filter restarts successfully NDIS_STATUS_XXX: Otherwise.</para>
</formalpara>
Start the datapath - begin sending and receiving NBLs. </para>

            </section>
            <section xml:id="group__NPF__code_1ga95739fd0dc3f0706723f6fa4528972b1">
                <title>FILTER_PAUSE NPF_Pause</title> <emphasis>Filter pause routine, Callback for NDIS PauseHandler.</emphasis>
                
<para>
                <formalpara>
                    <title/>
                    <table frame="all">
                        <title>Parameters                        </title>
                        <tgroup cols="2" align="left" colsep="1" rowsep="1">
                        <colspec colwidth="1*"/>
                        <colspec colwidth="4*"/>
                        <tbody>
                            <row>
                                <entry>FilterModuleContext</entry>
                                <entry>
<para>Pointer to the filter context structure. </para>
</entry>
                            </row>
                            <row>
                                <entry>PauseParameters</entry>
                                <entry>
<para>Additional information about the pause operation. </para>
</entry>
                            </row>
                        </tbody>
                        </tgroup>
                    </table>
                </formalpara>
                <formalpara><title>Returns: </title>

<para>NDIS_STATUS_SUCCESS if filter pauses successfully, NDIS_STATUS_PENDING if not. No other return value is allowed (pause must succeed, eventually).</para>
</formalpara>
Complete all the outstanding sends and queued sends, wait for all the outstanding recvs to be returned and return all the queued receives. N.B.: When the filter is in Pausing state, it can still process OID requests, complete sending, and returning packets to NDIS, and also indicate status. After this function completes, the filter must not attempt to send or receive packets, but it may still process OID requests and status indications. </para>

            </section>
            <section xml:id="group__NPF__code_1ga10ee17ea67d95bb3181d15504766af8b">
                <title>FILTER_OID_REQUEST NPF_OidRequest</title> <emphasis></emphasis>
                
            </section>
            <section xml:id="group__NPF__code_1gacb9e2c3fa9a52b1100a33fa71ee2f375">
                <title>FILTER_CANCEL_OID_REQUEST NPF_CancelOidRequest</title> <emphasis></emphasis>
                
            </section>
            <section xml:id="group__NPF__code_1ga19e4d4a1b5137ac74dad1fbd8c1ea43d">
                <title>FILTER_OID_REQUEST_COMPLETE NPF_OidRequestComplete</title> <emphasis></emphasis>
                
            </section>
            <section xml:id="group__NPF__code_1gadfce5805f2e2026d08c275bd495cc87a">
                <title>FILTER_STATUS NPF_Status</title> <emphasis>Callback for NDIS StatusHandler. Not used by NPF.</emphasis>
                
            </section>
            <section xml:id="group__NPF__code_1gaeae1fa7b69f4374d66377f02aebb7c30">
                <title>FILTER_DEVICE_PNP_EVENT_NOTIFY NPF_DevicePnPEventNotify</title> <emphasis>Device PNP event handler.</emphasis>
                
<para>
                <formalpara>
                    <title/>
                    <table frame="all">
                        <title>Parameters                        </title>
                        <tgroup cols="2" align="left" colsep="1" rowsep="1">
                        <colspec colwidth="1*"/>
                        <colspec colwidth="4*"/>
                        <tbody>
                            <row>
                                <entry>FilterModuleContext</entry>
                                <entry>
<para>Pointer to the filter context structure. </para>
</entry>
                            </row>
                            <row>
                                <entry>NetDevicePnPEvent</entry>
                                <entry>
<para>A Device PnP event.</para>
</entry>
                            </row>
                        </tbody>
                        </tgroup>
                    </table>
                </formalpara>
                Callback for NDIS DevicePnPEventNotifyHandler. Not used by NPF </para>

            </section>
            <section xml:id="group__NPF__code_1ga81b05ccf273c2f945fb3f21da2788649">
                <title>FILTER_NET_PNP_EVENT NPF_NetPnPEvent</title> <emphasis>Net PNP event handler.</emphasis>
                
<para>
                <formalpara>
                    <title/>
                    <table frame="all">
                        <title>Parameters                        </title>
                        <tgroup cols="2" align="left" colsep="1" rowsep="1">
                        <colspec colwidth="1*"/>
                        <colspec colwidth="4*"/>
                        <tbody>
                            <row>
                                <entry>FilterModuleContext</entry>
                                <entry>
<para>Pointer to the filter context structure. </para>
</entry>
                            </row>
                            <row>
                                <entry>NetPnPEventNotification</entry>
                                <entry>
<para>A Net PnP event. </para>
</entry>
                            </row>
                        </tbody>
                        </tgroup>
                    </table>
                </formalpara>
                <formalpara><title>Returns: </title>

<para>NDIS_STATUS_XXX</para>
</formalpara>
Callback for NDIS NetPnPEventHandler. Not used by NPF </para>

            </section>
            <section xml:id="group__NPF__code_1ga8a224321a819c50b39c65deb6feb2990">
                <title>FILTER_SEND_NET_BUFFER_LISTS NPF_SendEx</title> <emphasis>Callback for NDIS SendNetBufferListsHandler.</emphasis>
                
<para>
                <formalpara>
                    <title/>
                    <table frame="all">
                        <title>Parameters                        </title>
                        <tgroup cols="2" align="left" colsep="1" rowsep="1">
                        <colspec colwidth="1*"/>
                        <colspec colwidth="4*"/>
                        <tbody>
                            <row>
                                <entry>FilterModuleContext</entry>
                                <entry>
<para>Pointer to the filter context structure. </para>
</entry>
                            </row>
                            <row>
                                <entry>NetBufferLists</entry>
                                <entry>
<para>A List of NetBufferLists to send. </para>
</entry>
                            </row>
                            <row>
                                <entry>PortNumber</entry>
                                <entry>
<para>Port Number to which this send is targeted. </para>
</entry>
                            </row>
                            <row>
                                <entry>SendFlags</entry>
                                <entry>
<para>Specifies if the call is at DISPATCH_LEVEL.</para>
</entry>
                            </row>
                        </tbody>
                        </tgroup>
                    </table>
                </formalpara>
                This function is an optional function for filter drivers. If provided, NDIS will call this function to transmit a linked list of NetBuffers, described by a NetBufferList, over the network. If this handler is NULL, NDIS will skip calling this filter when sending a NetBufferList and will call the next lower driver in the stack. A filter that doesn&apos;t provide a FilerSendNetBufferList handler can not originate a send on its own. </para>

            </section>
            <section xml:id="group__NPF__code_1ga7bf507f2ea2c1a99e425d983f522718e">
                <title>FILTER_RETURN_NET_BUFFER_LISTS NPF_ReturnEx</title> <emphasis>Callback for NDIS ReturnNetBufferListsHandler.</emphasis>
                
<para>
                <formalpara>
                    <title/>
                    <table frame="all">
                        <title>Parameters                        </title>
                        <tgroup cols="2" align="left" colsep="1" rowsep="1">
                        <colspec colwidth="1*"/>
                        <colspec colwidth="4*"/>
                        <tbody>
                            <row>
                                <entry>FilterModuleContext</entry>
                                <entry>
<para>Pointer to the filter context structure. </para>
</entry>
                            </row>
                            <row>
                                <entry>NetBufferLists</entry>
                                <entry>
<para>A linked list of NetBufferLists that this filter driver indicated in a previous call to NdisFIndicateReceiveNetBufferLists. </para>
</entry>
                            </row>
                            <row>
                                <entry>ReturnFlags</entry>
                                <entry>
<para>Flags specifying if the caller is at DISPATCH_LEVEL.</para>
</entry>
                            </row>
                        </tbody>
                        </tgroup>
                    </table>
                </formalpara>
                FilterReturnNetBufferLists is an optional function. If provided, NDIS calls FilterReturnNetBufferLists to return the ownership of one or more NetBufferLists and their embedded NetBuffers to the filter driver. If this handler is NULL, NDIS will skip calling this filter when returning NetBufferLists to the underlying miniport and will call the next lower driver in the stack. A filter that doesn&apos;t provide a FilterReturnNetBufferLists handler cannot originate a receive indication on its own. </para>

            </section>
            <section xml:id="group__NPF__code_1gaf574b5a81173554f2c44f197d633c882">
                <title>FILTER_SEND_NET_BUFFER_LISTS_COMPLETE NPF_SendCompleteEx</title> <emphasis>Callback for NDIS SendNetBufferListsCompleteHandler.</emphasis>
                
<para>
                <formalpara>
                    <title/>
                    <table frame="all">
                        <title>Parameters                        </title>
                        <tgroup cols="2" align="left" colsep="1" rowsep="1">
                        <colspec colwidth="1*"/>
                        <colspec colwidth="4*"/>
                        <tbody>
                            <row>
                                <entry>FilterModuleContext</entry>
                                <entry>
<para>Pointer to the filter context structure. </para>
</entry>
                            </row>
                            <row>
                                <entry>NetBufferLists</entry>
                                <entry>
<para>A chain of NBLs that are being returned to you. </para>
</entry>
                            </row>
                            <row>
                                <entry>SendCompleteFlags</entry>
                                <entry>
<para>Flags (see documentation).</para>
</entry>
                            </row>
                        </tbody>
                        </tgroup>
                    </table>
                </formalpara>
                This routine is invoked whenever the lower layer is finished processing sent NET_BUFFER_LISTs. If the filter does not need to be involved in the send path, you should remove this routine and the FilterSendNetBufferLists routine. NDIS will pass along send packets on behalf of your filter more efficiently than the filter can. </para>

            </section>
            <section xml:id="group__NPF__code_1ga97357217815d777965c6114fde014b4c">
                <title>FILTER_RECEIVE_NET_BUFFER_LISTS NPF_TapEx</title> <emphasis>Callback for NDIS ReceiveNetBufferListsHandler.</emphasis>
                
<para>
                <formalpara>
                    <title/>
                    <table frame="all">
                        <title>Parameters                        </title>
                        <tgroup cols="2" align="left" colsep="1" rowsep="1">
                        <colspec colwidth="1*"/>
                        <colspec colwidth="4*"/>
                        <tbody>
                            <row>
                                <entry>FilterModuleContext</entry>
                                <entry>
<para>Pointer to the filter context structure. </para>
</entry>
                            </row>
                            <row>
                                <entry>NetBufferLists</entry>
                                <entry>
<para>A linked list of NetBufferLists. </para>
</entry>
                            </row>
                            <row>
                                <entry>PortNumber</entry>
                                <entry>
<para>Port on which the receive is indicated. </para>
</entry>
                            </row>
                            <row>
                                <entry>NumberOfNetBufferLists</entry>
                                <entry>
<para>Number of NetBufferLists. </para>
</entry>
                            </row>
                            <row>
                                <entry>ReceiveFlags</entry>
                                <entry>
<para>Flags (see documentation).</para>
</entry>
                            </row>
                        </tbody>
                        </tgroup>
                    </table>
                </formalpara>
                FilerReceiveNetBufferLists is an optional function for filter drivers. If provided, this function processes receive indications made by underlying NIC or lower level filter drivers. This function can also be called as a result of loopback. If this handler is NULL, NDIS will skip calling this filter when processing a receive indication and will call the next higher driver in the stack. A filter that doesn&apos;t provide a FilterReceiveNetBufferLists handler cannot provide a FilterReturnNetBufferLists handler and cannot a initiate an original receive indication on its own. N.B.: It is important to check the ReceiveFlags in NDIS_TEST_RECEIVE_CANNOT_PEND. This controls whether the receive indication is an synchronous or asynchronous function call. </para>

            </section>
            <section xml:id="group__NPF__code_1ga68e4564ae596b0fb6b947a9485cc4102">
                <title>FILTER_CANCEL_SEND_NET_BUFFER_LISTS NPF_CancelSendNetBufferLists</title> <emphasis>Callback for NDIS CancelSendNetBufferListsHandler.</emphasis>
                
<para>
                <formalpara>
                    <title/>
                    <table frame="all">
                        <title>Parameters                        </title>
                        <tgroup cols="2" align="left" colsep="1" rowsep="1">
                        <colspec colwidth="1*"/>
                        <colspec colwidth="4*"/>
                        <tbody>
                            <row>
                                <entry>FilterModuleContext</entry>
                                <entry>
<para>Pointer to the filter context structure. </para>
</entry>
                            </row>
                            <row>
                                <entry>CancelId</entry>
                                <entry>
<para>An identifier for all NBLs that should be dequeued.</para>
</entry>
                            </row>
                        </tbody>
                        </tgroup>
                    </table>
                </formalpara>
                This function cancels any NET_BUFFER_LISTs pended in the filter and then calls the NdisFCancelSendNetBufferLists to propagate the cancel operation. If your driver does not queue any send NBLs, you may omit this routine. NDIS will propagate the cancelation on your behalf more efficiently. </para>

            </section>
            <section xml:id="group__NPF__code_1gaf92ab7626caa4a270cfad07ad97da927">
                <title>FILTER_SET_MODULE_OPTIONS NPF_SetModuleOptions</title> <emphasis>Callback for NDIS SetFilterModuleOptionsHandler.</emphasis>
                
<para>
                <formalpara>
                    <title/>
                    <table frame="all">
                        <title>Parameters                        </title>
                        <tgroup cols="2" align="left" colsep="1" rowsep="1">
                        <colspec colwidth="1*"/>
                        <colspec colwidth="4*"/>
                        <tbody>
                            <row>
                                <entry>FilterModuleContext</entry>
                                <entry>
<para>Pointer to the filter context structure. </para>
</entry>
                            </row>
                        </tbody>
                        </tgroup>
                    </table>
                </formalpara>
                <formalpara><title>Returns: </title>

<para>NDIS_STATUS_SUCCESS NDIS_STATUS_RESOURCES NDIS_STATUS_FAILURE</para>
</formalpara>
This function set the optional handlers for the filter. Not used by NPF </para>

            </section>
            <section xml:id="group__NPF__code_1ga4fdcbea54bcb9f97ab54ae0f41650622">
                <title>DRIVER_INITIALIZE DriverEntry</title> <emphasis>The initialization routine of the driver.</emphasis>
                
<para>
                <formalpara>
                    <title/>
                    <table frame="all">
                        <title>Parameters                        </title>
                        <tgroup cols="2" align="left" colsep="1" rowsep="1">
                        <colspec colwidth="1*"/>
                        <colspec colwidth="4*"/>
                        <tbody>
                            <row>
                                <entry>DriverObject</entry>
                                <entry>
<para>The driver object of NPF created by the system. </para>
</entry>
                            </row>
                            <row>
                                <entry>RegistryPath</entry>
                                <entry>
<para>The registry path containing the keys related to the driver. </para>
</entry>
                            </row>
                        </tbody>
                        </tgroup>
                    </table>
                </formalpara>
                <formalpara><title>Returns: </title>

<para>STATUS_SUCCESS STATUS_UNSUCCESSFUL.</para>
</formalpara>
DriverEntry is a mandatory function in a device driver. Like the main() of a user level program, it is called by the system when the driver is loaded in memory and started. Its purpose is to initialize the driver, performing all the allocations and the setup. In particular, DriverEntry registers all the driver&apos;s I/O callbacks, creates the devices, defines NPF as a protocol inside NDIS. </para>

            </section>
        </section>
        <section>
            <title>Function Documentation</title>
            <section xml:id="group__NPF__code_1ga8fcbaebfdbada64f9762e31fa96e9d6a">
                <title>VOID NPF_FreePackets (PNET_BUFFER_LIST NetBufferLists)</title> <emphasis>Function to free the Net Buffer Lists initiated by ourself.</emphasis>
                
            </section>
            <section xml:id="group__NPF__code_1ga4038247452c950134c0cb87609348469">
                <title>ULONG NPF_GetPhysicalMedium (NDIS_HANDLE FilterModuleContext)</title> <emphasis>Get the physical medium of the adapter.</emphasis>
                
<para>
                <formalpara>
                    <title/>
                    <table frame="all">
                        <title>Parameters                        </title>
                        <tgroup cols="2" align="left" colsep="1" rowsep="1">
                        <colspec colwidth="1*"/>
                        <colspec colwidth="4*"/>
                        <tbody>
                            <row>
                                <entry>FilterModuleContext</entry>
                                <entry>
<para>Pointer to the filter context structure. </para>
</entry>
                            </row>
                        </tbody>
                        </tgroup>
                    </table>
                </formalpara>
                <formalpara><title>Returns: </title>

<para>the physical medium.</para>
</formalpara>
This function is used to get the original adapter physical medium with a <link linkend="group__NPF__code_1gaff02b0a70a0aa85620445b9c197dc5de">NPF_AttachAdapter()</link>. </para>

            </section>
            <section xml:id="group__NPF__code_1ga16173e745bd6a3d0ead21256de38520e">
                <title>ULONG NPF_GetPacketFilter (NDIS_HANDLE FilterModuleContext)</title> <emphasis>Get the packet filter of the adapter.</emphasis>
                
<para>
                <formalpara>
                    <title/>
                    <table frame="all">
                        <title>Parameters                        </title>
                        <tgroup cols="2" align="left" colsep="1" rowsep="1">
                        <colspec colwidth="1*"/>
                        <colspec colwidth="4*"/>
                        <tbody>
                            <row>
                                <entry>FilterModuleContext</entry>
                                <entry>
<para>Pointer to the filter context structure. </para>
</entry>
                            </row>
                        </tbody>
                        </tgroup>
                    </table>
                </formalpara>
                <formalpara><title>Returns: </title>

<para>the packet filter.</para>
</formalpara>
This function is used to get the original adapter packet filter with a <link linkend="group__NPF__code_1gaff02b0a70a0aa85620445b9c197dc5de">NPF_AttachAdapter()</link>, it is stored in the HigherPacketFilter, the combination of HigherPacketFilter and MyPacketFilter will be the final packet filter the low-level adapter sees. </para>

            </section>
            <section xml:id="group__NPF__code_1ga40afb45f4ad8ac44da6d0b4b80c09568">
                <title>NDIS_STATUS NPF_SetPacketFilter (NDIS_HANDLE FilterModuleContext, ULONG PacketFilter)</title> <emphasis>Set the packet filter of the adapter.</emphasis>
                
<para>
                <formalpara>
                    <title/>
                    <table frame="all">
                        <title>Parameters                        </title>
                        <tgroup cols="2" align="left" colsep="1" rowsep="1">
                        <colspec colwidth="1*"/>
                        <colspec colwidth="4*"/>
                        <tbody>
                            <row>
                                <entry>FilterModuleContext</entry>
                                <entry>
<para>Pointer to the filter context structure. </para>
</entry>
                            </row>
                            <row>
                                <entry>packet</entry>
                                <entry>
<para>filter The packet filter </para>
</entry>
                            </row>
                        </tbody>
                        </tgroup>
                    </table>
                </formalpara>
                <formalpara><title>Returns: </title>

<para>Status of the set/query request.</para>
</formalpara>
This function is used to get the original adapter packet filter with a <link linkend="group__NPF__code_1gaff02b0a70a0aa85620445b9c197dc5de">NPF_AttachAdapter()</link>, it is stored in the HigherPacketFilter, the combination of HigherPacketFilter and MyPacketFilter will be the final packet filter the low-level adapter sees. </para>

            </section>
            <section xml:id="group__NPF__code_1gacaf4bc2ac781a1f215a92c930afc3ba6">
                <title>NDIS_STATUS NPF_DoInternalRequest (_In_ NDIS_HANDLE FilterModuleContext, _In_ NDIS_REQUEST_TYPE RequestType, _In_ NDIS_OID Oid, _Inout_updates_bytes_to_(InformationBufferLength, *pBytesProcessed) PVOID InformationBuffer, _In_ ULONG InformationBufferLength, _In_opt_ ULONG OutputBufferLength, _In_ ULONG MethodId, _Out_ PULONG pBytesProcessed)</title> <emphasis>Utility routine that forms and sends an NDIS_OID_REQUEST to the miniport adapter.</emphasis>
                
<para>
                <formalpara>
                    <title/>
                    <table frame="all">
                        <title>Parameters                        </title>
                        <tgroup cols="2" align="left" colsep="1" rowsep="1">
                        <colspec colwidth="1*"/>
                        <colspec colwidth="4*"/>
                        <tbody>
                            <row>
                                <entry>FilterModuleContext</entry>
                                <entry>
<para>Pointer to the filter context structure. </para>
</entry>
                            </row>
                            <row>
                                <entry>RequestType</entry>
                                <entry>
<para>NdisRequest[Set|Query|method]Information. </para>
</entry>
                            </row>
                            <row>
                                <entry>Oid</entry>
                                <entry>
<para>The object being set/queried. </para>
</entry>
                            </row>
                            <row>
                                <entry>InformationBuffer</entry>
                                <entry>
<para>Data for the request. </para>
</entry>
                            </row>
                            <row>
                                <entry>InformationBufferLength</entry>
                                <entry>
<para>Length of the above. </para>
</entry>
                            </row>
                            <row>
                                <entry>OutputBufferLength</entry>
                                <entry>
<para>Valid only for method request. </para>
</entry>
                            </row>
                            <row>
                                <entry>MethodId</entry>
                                <entry>
<para>Valid only for method request. </para>
</entry>
                            </row>
                            <row>
                                <entry>pBytesProcessed</entry>
                                <entry>
<para>Place to return bytes read/written. </para>
</entry>
                            </row>
                        </tbody>
                        </tgroup>
                    </table>
                </formalpara>
                <formalpara><title>Returns: </title>

<para>Status of the set/query request.</para>
</formalpara>
Utility routine that forms and sends an NDIS_OID_REQUEST to the miniport, waits for it to complete, and returns status to the caller. NOTE: this assumes that the calling routine ensures validity of the filter handle until this returns. </para>

            </section>
            <section xml:id="group__NPF__code_1ga0f4ceafd1a03ffa4999224d381f05069">
                <title>VOID NPF_InternalRequestComplete (_In_ NDIS_HANDLE FilterModuleContext, _In_ PNDIS_OID_REQUEST NdisRequest, _In_ NDIS_STATUS Status)</title> <emphasis>Self-sent request handler.</emphasis>
                
<para>
                <formalpara>
                    <title/>
                    <table frame="all">
                        <title>Parameters                        </title>
                        <tgroup cols="2" align="left" colsep="1" rowsep="1">
                        <colspec colwidth="1*"/>
                        <colspec colwidth="4*"/>
                        <tbody>
                            <row>
                                <entry>FilterModuleContext</entry>
                                <entry>
<para>Pointer to the filter context structure. </para>
</entry>
                            </row>
                            <row>
                                <entry>NdisRequest</entry>
                                <entry>
<para>Pointer to NDIS request. </para>
</entry>
                            </row>
                            <row>
                                <entry>Status</entry>
                                <entry>
<para>Status of request completion.</para>
</entry>
                            </row>
                        </tbody>
                        </tgroup>
                    </table>
                </formalpara>
                NDIS entry point indicating completion of a pended self-sent NDIS_OID_REQUEST, called by NPF_OidRequestComplete. </para>

            </section>
            <section xml:id="group__NPF__code_1ga03c8b625d6dbd8c32aa052e75d91faf0">
                <title>ULONG My_NdisGroupMaxProcessorCount ()</title> <emphasis>Returns the maximum number of processors in the machine.</emphasis>
                
<para><formalpara><title>Returns: </title>

<para>A ULONG value for the maximum number of processors of the machine. </para>
</formalpara>
</para>

            </section>
            <section xml:id="group__NPF__code_1gac13d66181916327d6ec6ea241aa92d31">
                <title>ULONG My_KeGetCurrentProcessorNumber ()</title> <emphasis>Returns the processor number of the logical processor that the caller is running on.</emphasis>
                
<para><formalpara><title>Returns: </title>

<para>A ULONG value for the system-wide processor index of the logical processor that the caller is running on. </para>
</formalpara>
</para>

            </section>
            <section xml:id="group__NPF__code_1ga583e25304494a20cc26b314f35b4c4a7">
                <title>VOID NPF_registerLWF (PNDIS_FILTER_DRIVER_CHARACTERISTICS pFChars, BOOLEAN bWiFiOrNot)</title> <emphasis>The initialization routine of the LWF data structure.</emphasis>
                
<para>
                <formalpara>
                    <title/>
                    <table frame="all">
                        <title>Parameters                        </title>
                        <tgroup cols="2" align="left" colsep="1" rowsep="1">
                        <colspec colwidth="1*"/>
                        <colspec colwidth="4*"/>
                        <tbody>
                            <row>
                                <entry>pFChars</entry>
                                <entry>
<para>The LWF data structure. </para>
</entry>
                            </row>
                            <row>
                                <entry>bWiFiOrNot</entry>
                                <entry>
<para>Whether the LWF is registered as a WiFi one or standard one. </para>
</entry>
                            </row>
                        </tbody>
                        </tgroup>
                    </table>
                </formalpara>
                <formalpara><title>Returns: </title>

<para>NULL </para>
</formalpara>
</para>

            </section>
            <section xml:id="group__NPF__code_1ga4d4285c1178ae2e7aa2ee2e7cbb962fa">
                <title>PWCHAR getAdaptersList ()</title> <emphasis>Returns the list of the MACs available on the system.</emphasis>
                
<para><formalpara><title>Returns: </title>

<para>A string containing a list of network adapters.</para>
</formalpara>
The list of adapters is retrieved from the SYSTEM\CurrentControlSet\Control\Class\{4D36E972-E325-11CE-BFC1-08002BE10318} registry key. NPF tries to create its bindings from this list. In this way it is possible to be loaded and unloaded dynamically without passing from the control panel. </para>

            </section>
            <section xml:id="group__NPF__code_1gac9fd20e0896f418bcbe8891cac9264a6">
                <title>PKEY_VALUE_PARTIAL_INFORMATION getTcpBindings ()</title> <emphasis>Returns the MACs that bind to TCP/IP.</emphasis>
                
<para><formalpara><title>Returns: </title>

<para>Pointer to the registry key containing the list of adapters on which TCP/IP is bound.</para>
</formalpara>
If <link linkend="group__NPF__code_1ga4d4285c1178ae2e7aa2ee2e7cbb962fa">getAdaptersList()</link> fails, NPF tries to obtain the TCP/IP bindings through this function. </para>

            </section>
            <section xml:id="group__NPF__code_1gaea8c5091e715c9fe3861b85eb9df3fa9">
                <title>ULONG NPF_GetRegistryOption_Integer (PUNICODE_STRING RegistryPath, PUNICODE_STRING RegValueName)</title> <emphasis>read Npcap software&apos;s registry, get the option.</emphasis>
                
<para>If the registry key doesn&apos;t exist, we view the result as 0. </para>

            </section>
            <section xml:id="group__NPF__code_1ga3d90362bd8afff10c568dacf8da63497">
                <title>VOID NPF_GetRegistryOption_String ()</title> <emphasis>read Npcap software&apos;s registry, get the loopback adapter&apos;s device name and then put the name into global variable: g_LoopbackAdapterName. This name will be check in NPF_CreateDevice() function.</emphasis>
                
<para>If NPF_GetLoopbackAdapterName() fails, g_LoopbackAdapterName will be NULL. </para>

            </section>
            <section xml:id="group__NPF__code_1ga9a0324855f0f3c78f5849141b2b762c1">
                <title>BOOLEAN NPF_CreateDevice (IN OUT PDRIVER_OBJECT DriverObject, IN PUNICODE_STRING AdapterName, IN PUNICODE_STRING NPF_Prefix, IN BOOLEAN Dot11)</title> <emphasis>Creates a device for a given MAC.</emphasis>
                
<para>
                <formalpara>
                    <title/>
                    <table frame="all">
                        <title>Parameters                        </title>
                        <tgroup cols="2" align="left" colsep="1" rowsep="1">
                        <colspec colwidth="1*"/>
                        <colspec colwidth="4*"/>
                        <tbody>
                            <row>
                                <entry>adriverObjectP</entry>
                                <entry>
<para>The driver object that will be associated with the device, i.e. the one of NPF. </para>
</entry>
                            </row>
                            <row>
                                <entry>amacNameP</entry>
                                <entry>
<para>The name of the network interface that the device will point. </para>
</entry>
                            </row>
                        </tbody>
                        </tgroup>
                    </table>
                </formalpara>
                <formalpara><title>Returns: </title>

<para>If the function succeeds, the return value is nonzero.</para>
</formalpara>
NPF creates a device for every valid network adapter. The new device points to the NPF driver, but contains information about the original device. In this way, when the user opens the new device, NPF will be able to determine the correct adapter to use. </para>

            </section>
            <section xml:id="group__NPF__code_1ga27adfea80e4f27216ea3e26ea4824abc">
                <title>_Dispatch_type_ (IRP_MJ_CREATE) DRIVER_DISPATCH NPF_OpenAdapter</title> <emphasis>Opens a new instance of the driver.</emphasis>
                
<para>
                <formalpara>
                    <title/>
                    <table frame="all">
                        <title>Parameters                        </title>
                        <tgroup cols="2" align="left" colsep="1" rowsep="1">
                        <colspec colwidth="1*"/>
                        <colspec colwidth="4*"/>
                        <tbody>
                            <row>
                                <entry>DeviceObject</entry>
                                <entry>
<para>Pointer to the device object utilized by the user. </para>
</entry>
                            </row>
                            <row>
                                <entry>Irp</entry>
                                <entry>
<para>Pointer to the IRP containing the user request. </para>
</entry>
                            </row>
                        </tbody>
                        </tgroup>
                    </table>
                </formalpara>
                <formalpara><title>Returns: </title>

<para>The status of the operation. See ntstatus.h in the DDK.</para>
</formalpara>
This function is called by the OS when a new instance of the driver is opened, i.e. when a user application performs a CreateFile on a device created by NPF. NPF_Open allocates and initializes variables, objects and buffers needed by the new instance, fills the OPEN_INSTANCE structure associated with it and opens the adapter with a call to NdisOpenAdapter. </para>

            </section>
            <section xml:id="group__NPF__code_1ga8eb569f58457bc951486e6d07dee9d67">
                <title>_Dispatch_type_ (IRP_MJ_CLEANUP) DRIVER_DISPATCH NPF_Cleanup</title> <emphasis>Closes an instance of the driver.</emphasis>
                
<para>
                <formalpara>
                    <title/>
                    <table frame="all">
                        <title>Parameters                        </title>
                        <tgroup cols="2" align="left" colsep="1" rowsep="1">
                        <colspec colwidth="1*"/>
                        <colspec colwidth="4*"/>
                        <tbody>
                            <row>
                                <entry>DeviceObject</entry>
                                <entry>
<para>Pointer to the device object utilized by the user. </para>
</entry>
                            </row>
                            <row>
                                <entry>Irp</entry>
                                <entry>
<para>Pointer to the IRP containing the user request. </para>
</entry>
                            </row>
                        </tbody>
                        </tgroup>
                    </table>
                </formalpara>
                <formalpara><title>Returns: </title>

<para>The status of the operation. See ntstatus.h in the DDK.</para>
</formalpara>
This function is called when a running instance of the driver is closed by the user with a CloseHandle(). Used together with NPF_CloseAdapter(). It stops the capture/monitoring/dump process, deallocates the memory and the objects associated with the instance and closing the files. The network adapter is then closed with a call to NdisCloseAdapter. </para>

            </section>
            <section xml:id="group__NPF__code_1ga2db095d0ced7dc5f32deba345ee42456">
                <title>_Dispatch_type_ (IRP_MJ_CLOSE) DRIVER_DISPATCH NPF_CloseAdapter</title> <emphasis>Closes an instance of the driver.</emphasis>
                
<para>
                <formalpara>
                    <title/>
                    <table frame="all">
                        <title>Parameters                        </title>
                        <tgroup cols="2" align="left" colsep="1" rowsep="1">
                        <colspec colwidth="1*"/>
                        <colspec colwidth="4*"/>
                        <tbody>
                            <row>
                                <entry>DeviceObject</entry>
                                <entry>
<para>Pointer to the device object utilized by the user. </para>
</entry>
                            </row>
                            <row>
                                <entry>Irp</entry>
                                <entry>
<para>Pointer to the IRP containing the user request. </para>
</entry>
                            </row>
                        </tbody>
                        </tgroup>
                    </table>
                </formalpara>
                <formalpara><title>Returns: </title>

<para>The status of the operation. See ntstatus.h in the DDK.</para>
</formalpara>
This function is called when a running instance of the driver is closed by the user with a CloseHandle(). Used together with NPF_Cleanup(). It stops the capture/monitoring/dump process, deallocates the memory and the objects associated with the instance and closing the files. The network adapter is then closed with a call to NdisCloseAdapter. </para>

            </section>
            <section xml:id="group__NPF__code_1gae4ee83bd493a7fd3d57a43ace557f5ca">
                <title>VOID NPF_TapExForEachOpen (IN POPEN_INSTANCE Open, IN PNET_BUFFER_LIST pNetBufferLists)</title> <emphasis>Callback invoked by NPF_TapEx() when a packet arrives from the network.</emphasis>
                
<para>
                <formalpara>
                    <title/>
                    <table frame="all">
                        <title>Parameters                        </title>
                        <tgroup cols="2" align="left" colsep="1" rowsep="1">
                        <colspec colwidth="1*"/>
                        <colspec colwidth="4*"/>
                        <tbody>
                            <row>
                                <entry>Open</entry>
                                <entry>
<para>Pointer to an OPEN_INSTANCE structure to which the packets are destined. </para>
</entry>
                            </row>
                            <row>
                                <entry>pNetBufferLists</entry>
                                <entry>
<para>A List of NetBufferLists to receive.</para>
</entry>
                            </row>
                        </tbody>
                        </tgroup>
                    </table>
                </formalpara>
                <link linkend="group__NPF__code_1gae4ee83bd493a7fd3d57a43ace557f5ca">NPF_TapExForEachOpen()</link> is called by the underlying NIC for every incoming packet. It is the most important and one of the most complex functions of NPF: it executes the filter, runs the statistical engine (if the instance is in statistical mode), gathers the timestamp, moves the packet in the buffer. NPF_tap() is the only function, along with the filtering ones, that is executed for every incoming packet, therefore it is carefully optimized. </para>

            </section>
            <section xml:id="group__NPF__code_1ga574f32dfea14937d984bfe6cea990661">
                <title>_Dispatch_type_ (IRP_MJ_DEVICE_CONTROL) _IRQL_requires_max_(PASSIVE_LEVEL) DRIVER_DISPATCH NPF_IoControl</title> <emphasis>Handles the IOCTL calls.</emphasis>
                
<para>
                <formalpara>
                    <title/>
                    <table frame="all">
                        <title>Parameters                        </title>
                        <tgroup cols="2" align="left" colsep="1" rowsep="1">
                        <colspec colwidth="1*"/>
                        <colspec colwidth="4*"/>
                        <tbody>
                            <row>
                                <entry>DeviceObject</entry>
                                <entry>
<para>Pointer to the device object utilized by the user. </para>
</entry>
                            </row>
                            <row>
                                <entry>Irp</entry>
                                <entry>
<para>Pointer to the IRP containing the user request. </para>
</entry>
                            </row>
                        </tbody>
                        </tgroup>
                    </table>
                </formalpara>
                <formalpara><title>Returns: </title>

<para>The status of the operation. See ntstatus.h in the DDK.</para>
</formalpara>
Once the packet capture driver is opened it can be configured from user-level applications with IOCTL commands using the DeviceIoControl() system call. NPF_IoControl receives and serves all the IOCTL calls directed to NPF. The following commands are recognized:<itemizedlist>
<listitem>
<para><link linkend="group__NPF__ioctl_1ga71817d3a52bf0ec819934a5f688a172c">BIOCSETBUFFERSIZE</link></para>
</listitem><listitem>
<para><link linkend="group__NPF__ioctl_1gaf85f500f68404076ac60ffe6e08818da">BIOCSETF</link></para>
</listitem><listitem>
<para><link linkend="group__NPF__ioctl_1ga8ae8be8faa281644d8be1cda38b826bd">BIOCGSTATS</link></para>
</listitem><listitem>
<para><link linkend="group__NPF__ioctl_1ga327015c2b2e347212b571d1fa3aa2f54">BIOCSRTIMEOUT</link></para>
</listitem><listitem>
<para><link linkend="group__NPF__ioctl_1gad1012b82859d09864d246b1fa99d48d6">BIOCSMODE</link></para>
</listitem><listitem>
<para><link linkend="group__NPF__ioctl_1ga1436997ce2947bbbe22b5400254438a1">BIOCSWRITEREP</link></para>
</listitem><listitem>
<para><link linkend="group__NPF__ioctl_1gaa827e3441e3f84abc7df5e30fcee96d1">BIOCSMINTOCOPY</link></para>
</listitem><listitem>
<para><link linkend="group__NPF__ioctl_1gabf9a4779fd5281607510edc8b5d766dd">BIOCSETOID</link></para>
</listitem><listitem>
<para><link linkend="group__NPF__ioctl_1ga5a0ab3231052ff323817e288dab2f127">BIOCQUERYOID</link></para>
</listitem><listitem>
<para><link linkend="group__NPF__ioctl_1gac8b51f8abae12f57a2ea8e8e4c0cd53c">BIOCSETDUMPFILENAME</link></para>
</listitem><listitem>
<para><link linkend="group__NPF__ioctl_1gadd9e03a96d297a33d7cee4d750c34eff">BIOCGEVNAME</link></para>
</listitem><listitem>
<para><link linkend="group__NPF__ioctl_1gab4d41e91e460bb101ef8ddb622a8e010">BIOCSENDPACKETSSYNC</link></para>
</listitem><listitem>
<para><link linkend="group__NPF__ioctl_1gac50830dc08762383dcb203a66e5c853d">BIOCSENDPACKETSNOSYNC</link> </para>
</listitem></itemizedlist>
</para>

            </section>
            <section xml:id="group__NPF__code_1ga6ce38ed96776a52a17ab033de5b6d0df">
                <title>_Dispatch_type_ (IRP_MJ_WRITE) DRIVER_DISPATCH NPF_Write</title> <emphasis>Writes a raw packet to the network.</emphasis>
                
<para>
                <formalpara>
                    <title/>
                    <table frame="all">
                        <title>Parameters                        </title>
                        <tgroup cols="2" align="left" colsep="1" rowsep="1">
                        <colspec colwidth="1*"/>
                        <colspec colwidth="4*"/>
                        <tbody>
                            <row>
                                <entry>DeviceObject</entry>
                                <entry>
<para>Pointer to the device object on which the user wrote the packet. </para>
</entry>
                            </row>
                            <row>
                                <entry>Irp</entry>
                                <entry>
<para>Pointer to the IRP containing the user request. </para>
</entry>
                            </row>
                        </tbody>
                        </tgroup>
                    </table>
                </formalpara>
                <formalpara><title>Returns: </title>

<para>The status of the operation. See ntstatus.h in the DDK.</para>
</formalpara>
This function is called by the OS in consequence of user WriteFile() call, with the data of the packet that must be sent on the net. The data is contained in the buffer associated with Irp, NPF_Write takes it and delivers it to the NIC driver via the NdisSend() function. The Nwrites field of the OPEN_INSTANCE structure associated with Irp indicates the number of copies of the packet that will be sent: more than one copy of the packet can be sent for performance reasons. </para>

            </section>
            <section xml:id="group__NPF__code_1ga9a97dd25ae757da4bfed3723a4eb4bce">
                <title>INT NPF_BufferedWrite (IN PIRP Irp, IN PCHAR UserBuff, IN ULONG UserBuffSize, BOOLEAN sync)</title> <emphasis>Writes a buffer of raw packets to the network.</emphasis>
                
<para>
                <formalpara>
                    <title/>
                    <table frame="all">
                        <title>Parameters                        </title>
                        <tgroup cols="2" align="left" colsep="1" rowsep="1">
                        <colspec colwidth="1*"/>
                        <colspec colwidth="4*"/>
                        <tbody>
                            <row>
                                <entry>Irp</entry>
                                <entry>
<para>Pointer to the IRP containing the user request. </para>
</entry>
                            </row>
                            <row>
                                <entry>UserBuff</entry>
                                <entry>
<para>Pointer to the buffer containing the packets to send. </para>
</entry>
                            </row>
                            <row>
                                <entry>UserBuffSize</entry>
                                <entry>
<para>Size of the buffer with the packets. </para>
</entry>
                            </row>
                            <row>
                                <entry>sync</entry>
                                <entry>
<para>If set to TRUE, the packets are transmitted respecting their timestamps. </para>
</entry>
                            </row>
                        </tbody>
                        </tgroup>
                    </table>
                </formalpara>
                <formalpara><title>Returns: </title>

<para>The amount of bytes actually sent. If the return value is smaller than the Size parameter, an error occurred during the send. The error can be caused by an adapter problem or by an inconsistent/bogus user buffer.</para>
</formalpara>
This function is called by the OS in consequence of a BIOCSENDPACKETSNOSYNC or a BIOCSENDPACKETSSYNC IOCTL. The buffer received as input parameter contains an arbitrary number of packets, each of which preceded by a <link linkend="structsf__pkthdr">sf_pkthdr</link> structure. <link linkend="group__NPF__code_1ga9a97dd25ae757da4bfed3723a4eb4bce">NPF_BufferedWrite()</link> scans the buffer and sends every packet via the NdisSend() function. When Sync is set to TRUE, the packets are synchronized with the KeQueryPerformanceCounter() function. This requires a remarkable amount of CPU, but allows to respect the timestamps associated with packets with a precision of some microseconds (depending on the precision of the performance counter of the machine). If Sync is false, the timestamps are ignored and the packets are sent as fat as possible. </para>

            </section>
            <section xml:id="group__NPF__code_1ga8861b474efcb6578c9fe2075ff3e6aef">
                <title>VOID NPF_WaitEndOfBufferedWrite (POPEN_INSTANCE Open)</title> <emphasis>Waits the completion of all the sends performed by NPF_BufferedWrite.</emphasis>
                
<para>
                <formalpara>
                    <title/>
                    <table frame="all">
                        <title>Parameters                        </title>
                        <tgroup cols="2" align="left" colsep="1" rowsep="1">
                        <colspec colwidth="1*"/>
                        <colspec colwidth="4*"/>
                        <tbody>
                            <row>
                                <entry>Open</entry>
                                <entry>
<para>Pointer to open context structure.</para>
</entry>
                            </row>
                        </tbody>
                        </tgroup>
                    </table>
                </formalpara>
                This function is used by NPF_BufferedWrite to wait the completion of all the sends before returning the control to the user. </para>

            </section>
            <section xml:id="group__NPF__code_1ga4290c442943ae36cf616862137ca0a87">
                <title>VOID NPF_SendCompleteExForEachOpen (IN POPEN_INSTANCE Open, BOOLEAN FreeBufAfterWrite)</title> <emphasis>Ends a send operation.</emphasis>
                
<para>
                <formalpara>
                    <title/>
                    <table frame="all">
                        <title>Parameters                        </title>
                        <tgroup cols="2" align="left" colsep="1" rowsep="1">
                        <colspec colwidth="1*"/>
                        <colspec colwidth="4*"/>
                        <tbody>
                            <row>
                                <entry>Open</entry>
                                <entry>
<para>Pointer to open context structure. </para>
</entry>
                            </row>
                            <row>
                                <entry>FreeBufAfterWrite</entry>
                                <entry>
<para>Whether the buffer should be freed.</para>
</entry>
                            </row>
                        </tbody>
                        </tgroup>
                    </table>
                </formalpara>
                Callback function associated with the NdisFSend() NDIS function. It is invoked by <link linkend="group__NPF__code_1gaf574b5a81173554f2c44f197d633c882">NPF_SendCompleteEx()</link> when the NIC driver has finished an OID request operation that was previously started by NPF_Write(). </para>

            </section>
            <section xml:id="group__NPF__code_1gae116b69870512a8b9f12c2e246d043e5">
                <title>VOID NPF_StatusEx (IN NDIS_HANDLE ProtocolBindingContext, IN PNDIS_STATUS_INDICATION StatusIndication)</title> <emphasis>Callback for NDIS StatusHandler. Not used by NPF.</emphasis>
                
            </section>
            <section xml:id="group__NPF__code_1ga70f97109adcd6de8b157534e5ecf2e56">
                <title>VOID NPF_StatusComplete (IN NDIS_HANDLE ProtocolBindingContext)</title> <emphasis>Callback for NDIS StatusCompleteHandler. Not used by NPF.</emphasis>
                
            </section>
            <section xml:id="group__NPF__code_1ga6330e925342da5060d8968dbbecfabdc">
                <title>_Dispatch_type_ (IRP_MJ_READ) DRIVER_DISPATCH NPF_Read</title> <emphasis>Function that serves the user&apos;s reads.</emphasis>
                
<para>
                <formalpara>
                    <title/>
                    <table frame="all">
                        <title>Parameters                        </title>
                        <tgroup cols="2" align="left" colsep="1" rowsep="1">
                        <colspec colwidth="1*"/>
                        <colspec colwidth="4*"/>
                        <tbody>
                            <row>
                                <entry>DeviceObject</entry>
                                <entry>
<para>Pointer to the device used by the user. </para>
</entry>
                            </row>
                            <row>
                                <entry>Irp</entry>
                                <entry>
<para>Pointer to the IRP containing the user request. </para>
</entry>
                            </row>
                        </tbody>
                        </tgroup>
                    </table>
                </formalpara>
                <formalpara><title>Returns: </title>

<para>The status of the operation. See ntstatus.h in the DDK.</para>
</formalpara>
This function is called by the OS in consequence of user ReadFile() call. It moves the data present in the kernel buffer to the user buffer associated with Irp. First of all, NPF_Read checks the amount of data in kernel buffer associated with current NPF instance.<itemizedlist>
<listitem>
<para>If the instance is in capture mode and the buffer contains more than <link linkend="group__NPF_1ga263f7d6f5db5625541d275380685f0b1">OPEN_INSTANCE::MinToCopy</link> bytes, NPF_Read moves the data in the user buffer and returns immediately. In this way, the read performed by the user is not blocking.</para>
</listitem><listitem>
<para>If the buffer contains less than MinToCopy bytes, the application&apos;s request isn&apos;t satisfied immediately, but it&apos;s blocked until at least MinToCopy bytes arrive from the net or the timeout on this read expires. The timeout is kept in the <link linkend="group__NPF_1gaa6709070de8443c026e3b86913942c2b">OPEN_INSTANCE::TimeOut</link> field.</para>
</listitem><listitem>
<para>If the instance is in statistical mode or in dump mode, the application&apos;s request is blocked until the timeout kept in <link linkend="group__NPF_1gaa6709070de8443c026e3b86913942c2b">OPEN_INSTANCE::TimeOut</link> expires. </para>
</listitem></itemizedlist>
</para>

            </section>
            <section xml:id="group__NPF__code_1gad04266456ecaa437122eee8dd3eddeca">
                <title>void NPF_AddToOpenArray (POPEN_INSTANCE Open)</title> <emphasis>Add the open context to the global open array.</emphasis>
                
<para>
                <formalpara>
                    <title/>
                    <table frame="all">
                        <title>Parameters                        </title>
                        <tgroup cols="2" align="left" colsep="1" rowsep="1">
                        <colspec colwidth="1*"/>
                        <colspec colwidth="4*"/>
                        <tbody>
                            <row>
                                <entry>Open</entry>
                                <entry>
<para>Pointer to open context structure.</para>
</entry>
                            </row>
                        </tbody>
                        </tgroup>
                    </table>
                </formalpara>
                This function is used by <link linkend="group__NPF__code_1gaff02b0a70a0aa85620445b9c197dc5de">NPF_AttachAdapter()</link> and NPF_OpenAdapter() to add a new open context to the global open array, this array is designed to help find and clean the specific adapter context. </para>

            </section>
            <section xml:id="group__NPF__code_1ga200a4e395f43a9b0a6769986dd0d9563">
                <title>void NPF_AddToGroupOpenArray (POPEN_INSTANCE Open, POPEN_INSTANCE GroupHead)</title> <emphasis>Add the open context to the group open array of a head adapter.</emphasis>
                
<para>
                <formalpara>
                    <title/>
                    <table frame="all">
                        <title>Parameters                        </title>
                        <tgroup cols="2" align="left" colsep="1" rowsep="1">
                        <colspec colwidth="1*"/>
                        <colspec colwidth="4*"/>
                        <tbody>
                            <row>
                                <entry>Open</entry>
                                <entry>
<para>Pointer to open context structure.</para>
</entry>
                            </row>
                        </tbody>
                        </tgroup>
                    </table>
                </formalpara>
                This function is used by NPF_OpenAdapter to add a new open context to the group open array of a head adapter, this array is designed to help find and clean the specific adapter context. A head adapter context is generated by <link linkend="group__NPF__code_1gaff02b0a70a0aa85620445b9c197dc5de">NPF_AttachAdapter()</link>, it handles with NDIS. A non-head adapter is generated by NPF_OpenAdapter(), it handles with the WinPcap up-level packet.dll and so on. Head adapter contexts are designed because NDIS 6.x only allows one-time binding, unlike NDIS 5.0. </para>

            </section>
            <section xml:id="group__NPF__code_1gabbdcba53431b4b034a2865a357fe7139">
                <title>void NPF_RemoveFromOpenArray (POPEN_INSTANCE Open)</title> <emphasis>Remove the open context from the global open array.</emphasis>
                
<para>
                <formalpara>
                    <title/>
                    <table frame="all">
                        <title>Parameters                        </title>
                        <tgroup cols="2" align="left" colsep="1" rowsep="1">
                        <colspec colwidth="1*"/>
                        <colspec colwidth="4*"/>
                        <tbody>
                            <row>
                                <entry>Open</entry>
                                <entry>
<para>Pointer to open context structure.</para>
</entry>
                            </row>
                        </tbody>
                        </tgroup>
                    </table>
                </formalpara>
                This function is used by <link linkend="group__NPF__code_1ga6b9046210a2eb5b094f17e0f456ec893">NPF_DetachAdapter()</link>, NPF_Cleanup() and NPF_CleanupForUnclosed() to remove an open context from the global open array. </para>

            </section>
            <section xml:id="group__NPF__code_1gacd6b083f1069a6ace93f867e063547d7">
                <title>void NPF_RemoveFromGroupOpenArray (POPEN_INSTANCE Open)</title> <emphasis>Remove the open context from the group open array of a head adapter.</emphasis>
                
<para>
                <formalpara>
                    <title/>
                    <table frame="all">
                        <title>Parameters                        </title>
                        <tgroup cols="2" align="left" colsep="1" rowsep="1">
                        <colspec colwidth="1*"/>
                        <colspec colwidth="4*"/>
                        <tbody>
                            <row>
                                <entry>Open</entry>
                                <entry>
<para>Pointer to open context structure.</para>
</entry>
                            </row>
                        </tbody>
                        </tgroup>
                    </table>
                </formalpara>
                This function is used by NPF_Cleanup() and NPF_CleanupForUnclosed() to remove an open context from the group open array of a head adapter. </para>

            </section>
            <section xml:id="group__NPF__code_1ga9239d79ad62d1d56393963d076b42949">
                <title>BOOLEAN NPF_EqualAdapterName (PNDIS_STRING s1, PNDIS_STRING s2)</title> <emphasis>Compare two NDIS strings.</emphasis>
                
<para>
                <formalpara>
                    <title/>
                    <table frame="all">
                        <title>Parameters                        </title>
                        <tgroup cols="2" align="left" colsep="1" rowsep="1">
                        <colspec colwidth="1*"/>
                        <colspec colwidth="4*"/>
                        <tbody>
                            <row>
                                <entry>s1</entry>
                                <entry>
<para>The first string. </para>
</entry>
                            </row>
                            <row>
                                <entry>s2</entry>
                                <entry>
<para>The second string. </para>
</entry>
                            </row>
                        </tbody>
                        </tgroup>
                    </table>
                </formalpara>
                <formalpara><title>Returns: </title>

<para>1 if s1 &gt; s2 0 if s1 = s2 -1 if s1 &lt; s2</para>
</formalpara>
This function is used to help decide whether two adapter names are the same. </para>

            </section>
            <section xml:id="group__NPF__code_1ga2c7bf9f627c395096f806bad0ebd41cf">
                <title>POPEN_INSTANCE NPF_GetOpenByAdapterName (PNDIS_STRING pAdapterName, BOOLEAN Dot11)</title> <emphasis>Get a copy of open instance from the global array.</emphasis>
                
<para>
                <formalpara>
                    <title/>
                    <table frame="all">
                        <title>Parameters                        </title>
                        <tgroup cols="2" align="left" colsep="1" rowsep="1">
                        <colspec colwidth="1*"/>
                        <colspec colwidth="4*"/>
                        <tbody>
                            <row>
                                <entry>pAdapterName</entry>
                                <entry>
<para>The adapter name of the target open instance. </para>
</entry>
                            </row>
                            <row>
                                <entry>DeviceExtension</entry>
                                <entry>
<para>Pointer to the <link linkend="struct__DEVICE__EXTENSION">_DEVICE_EXTENSION</link> structure of the device. </para>
</entry>
                            </row>
                        </tbody>
                        </tgroup>
                    </table>
                </formalpara>
                <formalpara><title>Returns: </title>

<para>Pointer to the new open instance.</para>
</formalpara>
This function is used to create a group member adapter for the group head one. </para>

            </section>
            <section xml:id="group__NPF__code_1ga759d14a6f8a32feaf146505024f77cfa">
                <title>POPEN_INSTANCE NPF_DuplicateOpenObject (POPEN_INSTANCE OriginalOpen, PDEVICE_EXTENSION DeviceExtension)</title> <emphasis>Get a copy of open instance from the global array.</emphasis>
                
<para>
                <formalpara>
                    <title/>
                    <table frame="all">
                        <title>Parameters                        </title>
                        <tgroup cols="2" align="left" colsep="1" rowsep="1">
                        <colspec colwidth="1*"/>
                        <colspec colwidth="4*"/>
                        <tbody>
                            <row>
                                <entry>OriginalOpen</entry>
                                <entry>
<para>The open instance need to be copied. </para>
</entry>
                            </row>
                            <row>
                                <entry>DeviceExtension</entry>
                                <entry>
<para>Pointer to the <link linkend="struct__DEVICE__EXTENSION">_DEVICE_EXTENSION</link> structure of the device. </para>
</entry>
                            </row>
                        </tbody>
                        </tgroup>
                    </table>
                </formalpara>
                <formalpara><title>Returns: </title>

<para>Pointer to the new open instance.</para>
</formalpara>
This function is used by NPF_GetCopyFromOpenArray(). </para>

            </section>
            <section xml:id="group__NPF__code_1ga9b229409688200ac6e9b1ef66e32a3ed">
                <title>POPEN_INSTANCE NPF_CreateOpenObject (PNDIS_STRING AdapterName, UINT SelectedIndex, PDEVICE_EXTENSION DeviceExtension)</title> <emphasis>Create a open instance.</emphasis>
                
<para>
                <formalpara>
                    <title/>
                    <table frame="all">
                        <title>Parameters                        </title>
                        <tgroup cols="2" align="left" colsep="1" rowsep="1">
                        <colspec colwidth="1*"/>
                        <colspec colwidth="4*"/>
                        <tbody>
                            <row>
                                <entry>AdapterName</entry>
                                <entry>
<para>The adapter name of the target open instance. </para>
</entry>
                            </row>
                            <row>
                                <entry>SelectedIndex</entry>
                                <entry>
<para>The medium of the open instance. </para>
</entry>
                            </row>
                            <row>
                                <entry>DeviceExtension</entry>
                                <entry>
<para>Pointer to the <link linkend="struct__DEVICE__EXTENSION">_DEVICE_EXTENSION</link> structure of the device. </para>
</entry>
                            </row>
                        </tbody>
                        </tgroup>
                    </table>
                </formalpara>
                <formalpara><title>Returns: </title>

<para>Pointer to the new open instance.</para>
</formalpara>
This function is used to create a group head open instance or a group member open instance. </para>

            </section>
            <section xml:id="group__NPF__code_1gae3d1118c72b474fe214517a65afdfe09">
                <title>NTSTATUS NPF_OpenDumpFile (POPEN_INSTANCE Open, PUNICODE_STRING fileName, BOOLEAN append)</title> <emphasis>Creates the file that will receive the packets when the driver is in dump mode.</emphasis>
                
<para>
                <formalpara>
                    <title/>
                    <table frame="all">
                        <title>Parameters                        </title>
                        <tgroup cols="2" align="left" colsep="1" rowsep="1">
                        <colspec colwidth="1*"/>
                        <colspec colwidth="4*"/>
                        <tbody>
                            <row>
                                <entry>Open</entry>
                                <entry>
<para>The NPF instance that opens the file. </para>
</entry>
                            </row>
                            <row>
                                <entry>fileName</entry>
                                <entry>
<para>Pointer to a UNICODE string containing the name of the file. </para>
</entry>
                            </row>
                            <row>
                                <entry>append</entry>
                                <entry>
<para>Boolean value that specifies if the data must be appended to the file. </para>
</entry>
                            </row>
                        </tbody>
                        </tgroup>
                    </table>
                </formalpara>
                <formalpara><title>Returns: </title>

<para>The status of the operation. See ntstatus.h in the DDK. </para>
</formalpara>
</para>

            </section>
            <section xml:id="group__NPF__code_1gaeffce124cbc3e3ae09bd7a6d10367cbb">
                <title>NTSTATUS NPF_StartDump (POPEN_INSTANCE Open)</title> <emphasis>Starts dump to file.</emphasis>
                
<para>
                <formalpara>
                    <title/>
                    <table frame="all">
                        <title>Parameters                        </title>
                        <tgroup cols="2" align="left" colsep="1" rowsep="1">
                        <colspec colwidth="1*"/>
                        <colspec colwidth="4*"/>
                        <tbody>
                            <row>
                                <entry>Open</entry>
                                <entry>
<para>The NPF instance that opens the file. </para>
</entry>
                            </row>
                        </tbody>
                        </tgroup>
                    </table>
                </formalpara>
                <formalpara><title>Returns: </title>

<para>The status of the operation. See ntstatus.h in the DDK.</para>
</formalpara>
This function performs two operations. First, it writes the libpcap header at the beginning of the file. Second, it starts the thread that asynchronously dumps the network data to the file. </para>

            </section>
            <section xml:id="group__NPF__code_1ga1566082cef91cf79ba4a855e3f44ede9">
                <title>VOID NPF_DumpThread (PVOID Open)</title> <emphasis>The dump thread.</emphasis>
                
<para>
                <formalpara>
                    <title/>
                    <table frame="all">
                        <title>Parameters                        </title>
                        <tgroup cols="2" align="left" colsep="1" rowsep="1">
                        <colspec colwidth="1*"/>
                        <colspec colwidth="4*"/>
                        <tbody>
                            <row>
                                <entry>Open</entry>
                                <entry>
<para>The NPF instance that creates the thread.</para>
</entry>
                            </row>
                        </tbody>
                        </tgroup>
                    </table>
                </formalpara>
                This function moves the content of the NPF kernel buffer to file. It runs in the user context, so at lower priority than the TAP. </para>

            </section>
            <section xml:id="group__NPF__code_1gafcdcf5a4d9bfb8fbdb179963d4c789bd">
                <title>NTSTATUS NPF_SaveCurrentBuffer (POPEN_INSTANCE Open)</title> <emphasis>Saves the content of the packet buffer to the file associated with current instance.</emphasis>
                
<para>
                <formalpara>
                    <title/>
                    <table frame="all">
                        <title>Parameters                        </title>
                        <tgroup cols="2" align="left" colsep="1" rowsep="1">
                        <colspec colwidth="1*"/>
                        <colspec colwidth="4*"/>
                        <tbody>
                            <row>
                                <entry>Open</entry>
                                <entry>
<para>The NPF instance that creates the thread.</para>
</entry>
                            </row>
                        </tbody>
                        </tgroup>
                    </table>
                </formalpara>
                Used by <link linkend="group__NPF__code_1ga1566082cef91cf79ba4a855e3f44ede9">NPF_DumpThread()</link> and <link linkend="group__NPF__code_1gac911742b9f71c12c77452614db14c4a1">NPF_CloseDumpFile()</link>. </para>

            </section>
            <section xml:id="group__NPF__code_1ga57b9ee7752f00c8858bda8ca060a033b">
                <title>VOID NPF_WriteDumpFile (PFILE_OBJECT FileObject, PLARGE_INTEGER Offset, ULONG Length, PMDL Mdl, PIO_STATUS_BLOCK IoStatusBlock)</title> <emphasis>Writes a block of packets on the dump file.</emphasis>
                
<para>
                <formalpara>
                    <title/>
                    <table frame="all">
                        <title>Parameters                        </title>
                        <tgroup cols="2" align="left" colsep="1" rowsep="1">
                        <colspec colwidth="1*"/>
                        <colspec colwidth="4*"/>
                        <tbody>
                            <row>
                                <entry>FileObject</entry>
                                <entry>
<para>The file object that will receive the packets. </para>
</entry>
                            </row>
                            <row>
                                <entry>Offset</entry>
                                <entry>
<para>The offset in the file where the packets will be put. </para>
</entry>
                            </row>
                            <row>
                                <entry>Length</entry>
                                <entry>
<para>The amount of bytes to write. </para>
</entry>
                            </row>
                            <row>
                                <entry>Mdl</entry>
                                <entry>
<para>MDL mapping the memory buffer that will be written to disk. </para>
</entry>
                            </row>
                            <row>
                                <entry>IoStatusBlock</entry>
                                <entry>
<para>Used by the function to return the status of the operation. </para>
</entry>
                            </row>
                        </tbody>
                        </tgroup>
                    </table>
                </formalpara>
                <formalpara><title>Returns: </title>

<para>The status of the operation. See ntstatus.h in the DDK.</para>
</formalpara>
NPF_WriteDumpFile addresses directly the file system, creating a custom IRP and using it to send a portion of the NPF circular buffer to disk. This function is used by <link linkend="group__NPF__code_1ga1566082cef91cf79ba4a855e3f44ede9">NPF_DumpThread()</link>. </para>

            </section>
            <section xml:id="group__NPF__code_1gac911742b9f71c12c77452614db14c4a1">
                <title>NTSTATUS NPF_CloseDumpFile (POPEN_INSTANCE Open)</title> <emphasis>Closes the dump file associated with an instance of the driver.</emphasis>
                
<para>
                <formalpara>
                    <title/>
                    <table frame="all">
                        <title>Parameters                        </title>
                        <tgroup cols="2" align="left" colsep="1" rowsep="1">
                        <colspec colwidth="1*"/>
                        <colspec colwidth="4*"/>
                        <tbody>
                            <row>
                                <entry>Open</entry>
                                <entry>
<para>The NPF instance that closes the file. </para>
</entry>
                            </row>
                        </tbody>
                        </tgroup>
                    </table>
                </formalpara>
                <formalpara><title>Returns: </title>

<para>The status of the operation. See ntstatus.h in the DDK. </para>
</formalpara>
</para>

            </section>
            <section xml:id="group__NPF__code_1ga64dab96bfced5d22cc55a42fc6339833">
                <title>BOOLEAN NPF_StartUsingBinding (IN POPEN_INSTANCE pOpen)</title> <emphasis></emphasis>
                
            </section>
            <section xml:id="group__NPF__code_1gacd54077d4c2d9186486d3504523ba4f0">
                <title>VOID NPF_StopUsingBinding (IN POPEN_INSTANCE pOpen)</title> <emphasis></emphasis>
                
            </section>
            <section xml:id="group__NPF__code_1ga76d4e48415cea8e0e65ba93d7355b89f">
                <title>VOID NPF_CloseBinding (IN POPEN_INSTANCE pOpen)</title> <emphasis></emphasis>
                
            </section>
            <section xml:id="group__NPF__code_1ga504e61b1229a9a604080fc8607b24084">
                <title>BOOLEAN NPF_StartUsingOpenInstance (IN POPEN_INSTANCE pOpen)</title> <emphasis></emphasis>
                
            </section>
            <section xml:id="group__NPF__code_1ga6ceb77291c077b05efd3b588a6a30867">
                <title>VOID NPF_StopUsingOpenInstance (IN POPEN_INSTANCE pOpen)</title> <emphasis></emphasis>
                
            </section>
            <section xml:id="group__NPF__code_1ga99878d91732973e7b4020d8e42b4cf32">
                <title>VOID NPF_CloseOpenInstance (IN POPEN_INSTANCE pOpen)</title> <emphasis></emphasis>
                
            </section>
            <section xml:id="group__NPF__code_1ga208c887c5d9e995e59a8f5a39ed191c7">
                <title>NTSTATUS NPF_GetDeviceMTU (IN POPEN_INSTANCE pOpen, OUT PUINT pMtu)</title> <emphasis></emphasis>
                
            </section>
            <section xml:id="group__NPF__code_1gadd6737f745e21b37b8613b489a96687d">
                <title>UINT GetBuffOccupation (POPEN_INSTANCE Open)</title> <emphasis>Returns the amount of bytes present in the packet buffer.</emphasis>
                
<para>
                <formalpara>
                    <title/>
                    <table frame="all">
                        <title>Parameters                        </title>
                        <tgroup cols="2" align="left" colsep="1" rowsep="1">
                        <colspec colwidth="1*"/>
                        <colspec colwidth="4*"/>
                        <tbody>
                            <row>
                                <entry>Open</entry>
                                <entry>
<para>The NPF instance that closes the file. </para>
</entry>
                            </row>
                        </tbody>
                        </tgroup>
                    </table>
                </formalpara>
                </para>

            </section>
            <section xml:id="group__NPF__code_1gae4089cbcd9d643328f7ac79200049e84">
                <title>VOID NPF_ResetBufferContents (POPEN_INSTANCE Open)</title> <emphasis></emphasis>
                
            </section>
            <section xml:id="group__NPF__code_1gab95019314e0cce415388272574f85ed7">
                <title>JIT_BPF_Filter* BPF_jitter (struct bpf_insn *fp, INT nins)</title> <emphasis>BPF jitter, builds an x86 function from a BPF program.</emphasis>
                
<para>
                <formalpara>
                    <title/>
                    <table frame="all">
                        <title>Parameters                        </title>
                        <tgroup cols="2" align="left" colsep="1" rowsep="1">
                        <colspec colwidth="1*"/>
                        <colspec colwidth="4*"/>
                        <tbody>
                            <row>
                                <entry>fp</entry>
                                <entry>
<para>The BPF pseudo-assembly filter that will be translated into x86 code. </para>
</entry>
                            </row>
                            <row>
                                <entry>nins</entry>
                                <entry>
<para>Number of instructions of the input filter. </para>
</entry>
                            </row>
                        </tbody>
                        </tgroup>
                    </table>
                </formalpara>
                <formalpara><title>Returns: </title>

<para>The <link linkend="structJIT__BPF__Filter">JIT_BPF_Filter</link> structure containing the x86 filtering binary.</para>
</formalpara>
BPF_jitter allocates the buffers for the new native filter and then translates the program pointed by fp calling <link linkend="group__NPF__code_1gaac4070271462268d182b0dbdbfcb1a88">BPFtoX86()</link>. </para>

            </section>
            <section xml:id="group__NPF__code_1gaac4070271462268d182b0dbdbfcb1a88">
                <title>BPF_filter_function BPFtoX86 (struct bpf_insn *ins, UINT nins, INT *mem)</title> <emphasis>Translates a set of BPF instructions in a set of x86 ones.</emphasis>
                
<para>
                <formalpara>
                    <title/>
                    <table frame="all">
                        <title>Parameters                        </title>
                        <tgroup cols="2" align="left" colsep="1" rowsep="1">
                        <colspec colwidth="1*"/>
                        <colspec colwidth="4*"/>
                        <tbody>
                            <row>
                                <entry>ins</entry>
                                <entry>
<para>Pointer to the BPF instructions that will be translated into x86 code. </para>
</entry>
                            </row>
                            <row>
                                <entry>nins</entry>
                                <entry>
<para>Number of instructions to translate. </para>
</entry>
                            </row>
                            <row>
                                <entry>mem</entry>
                                <entry>
<para>Memory used by the x86 function to emulate the RAM of the BPF pseudo processor. </para>
</entry>
                            </row>
                        </tbody>
                        </tgroup>
                    </table>
                </formalpara>
                <formalpara><title>Returns: </title>

<para>The x86 filtering function.</para>
</formalpara>
This function does the hard work for the JIT compilation. It takes a group of BPF pseudo instructions and through the instruction macros defined in <link linkend="jitter_8h">jitter.h</link> it is able to create an function directly executable by NPF. </para>

            </section>
            <section xml:id="group__NPF__code_1ga8d441782c2295f2f71d32727dd3f28a0">
                <title>void BPF_Destroy_JIT_Filter (JIT_BPF_Filter *Filter)</title> <emphasis>Deletes a filtering function that was previously created by BPF_jitter().</emphasis>
                
<para>
                <formalpara>
                    <title/>
                    <table frame="all">
                        <title>Parameters                        </title>
                        <tgroup cols="2" align="left" colsep="1" rowsep="1">
                        <colspec colwidth="1*"/>
                        <colspec colwidth="4*"/>
                        <tbody>
                            <row>
                                <entry>Filter</entry>
                                <entry>
<para>The filter to destroy.</para>
</entry>
                            </row>
                        </tbody>
                        </tgroup>
                    </table>
                </formalpara>
                This function frees the variuos buffers (code, memory, etc.) associated with a filtering function. </para>

            </section>
        </section>
</section>
